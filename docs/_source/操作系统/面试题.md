### 1. 进程与线程的本质区别、以及各自的使用场景

> [参考链接](https://blog.csdn.net/baidu_37964044/article/details/81406866)

1. 一个进程可以有多个线程
2. 资源分配给进程，同一个进程的所有线程共享该进程的所有资源
3. CPU分派给线程，即真正在CPU上运行的是线程

**多进程的优点：**

1. `不用考虑锁和同步的问题`，编程相对容易。
2. `有更强的容错性`，如果一个进程崩溃了不会影响其他进程
3. 采用多进程程序一般可以做到一定程序的`自恢复`。【master守护进程监控所有worker进程，发现进程挂掉后将其重启】

**多线程的优势：**

1. `创建`速度快，方便高效的`共享数据`（共享内存，信号量等IPC技术）
2. `较轻的上下文切换`：不用切换地址空间，不用更改寄存器，不用刷新TLB快表
3. 提供非均质的服务：如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。

**多进程应用场景：**

1. nginx主流工作模式是多进程模式（也支持多线程模式）
2. 几乎所有的web server服务器都`有`多进程，至少有一个守护进程配合一个worker进程，例如apached，httpd等等以d结尾的进程。
3. chrome浏览器。（原因：一个网页如果不符合编程规范崩溃，不会影响其他进程；网页之间相互隔离，不用担心恶意代码获取其他网页敏感信息）
4. redis（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）

**多线程应用场景：**

1. `需要频繁创建销毁`的优先用线程（进程的创建和销毁开销过大）这种原则最常见的应用就是`Web服务器`了，`来一个连接建立一个线程`，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
2. 需要进行`大量计算`的优先使用线程（CPU频繁切换）所谓大量计算，当然就是要`耗费很多CPU`，切换频繁了，这种情况下线程是最合适的。这种原则最常见的是`图像处理、算法处理`。
3. 数据共享，不同任务频繁需要通信。
4. 迅雷下载

**但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。**

### 2. 进程的状态

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e6%8f%8f%e8%bf%b0%e5%8f%8a%e7%bb%84%e7%bb%87%e6%96%b9%e5%bc%8f%f0%9f%98%80>)

![../../_img/具有挂起状态的进程状态图.jpg](../../_img/../../_img/具有挂起状态的进程状态图.jpg)

### 3. 进程调度算法的特点以及使用场景

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6?id=_36-%e5%b8%b8%e7%94%a8%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95>)

**交互式系统中：**

1. 时间片轮转法
2. 优先级调度法：`动态优先级`,可以采用“论年头”的方法，即等待CPU很长时间的进程逐渐提升其优先级。时间片抢占。
3. 多级队列：把作业分别链入不同地队列，每个队列都由自己地调度算法
4. 多级反馈队列：高优先级队列的时间片小，低优先级队列的时间片大。新进程进入系统后，先放入第一队列的未尾，各队列按FCFS 方式排队；如某个进程在相应时间片内没有完成工作，则把它转到下一级队列的未尾；系统先运行第一队列中的进程，第一队列为空后才运行第二队列中的进程，以此类推， 最后一个队列（最低级）中的进程采用时间片轮转的方式进行调度。UNIX采用了类似的做法

**实时系统中：**

1. 实时调度算法

**批处理系统中：**

1. 先来先服务
2. 短作业优先
3. 最短剩余时间优先