### 1. 基础

#### ★★★ 进程与线程的本质区别、以及各自的使用场景

> [参考链接](https://blog.csdn.net/baidu_37964044/article/details/81406866)

1. 一个进程可以有多个线程
2. 资源分配给进程，同一个进程的所有线程共享该进程的所有资源
3. CPU分派给线程，即真正在CPU上运行的是线程

**多进程的优点：**

1. `不用考虑锁和同步的问题`，编程相对容易。
2. `有更强的容错性`，如果一个进程崩溃了不会影响其他进程
3. 采用多进程程序一般可以做到一定程序的`自恢复`。【master守护进程监控所有worker进程，发现进程挂掉后将其重启】

**多线程的优势：**

1. `创建`速度快，方便高效的`共享数据`（共享内存，信号量等IPC技术）
2. `较轻的上下文切换`：不用切换地址空间，不用更改寄存器，不用刷新TLB快表
3. 提供非均质的服务：如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。

**多进程应用场景：**

1. nginx主流工作模式是多进程模式（也支持多线程模式）
2. 几乎所有的web server服务器都`有`多进程，至少有一个守护进程配合一个worker进程，例如apached，httpd等等以d结尾的进程。
3. chrome浏览器。（原因：一个网页如果不符合编程规范崩溃，不会影响其他进程；网页之间相互隔离，不用担心恶意代码获取其他网页敏感信息）
4. redis（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）

**多线程应用场景：**

1. `需要频繁创建销毁`的优先用线程（进程的创建和销毁开销过大）这种原则最常见的应用就是`Web服务器`了，`来一个连接建立一个线程`，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
2. 需要进行`大量计算`的优先使用线程（CPU频繁切换）所谓大量计算，当然就是要`耗费很多CPU`，切换频繁了，这种情况下线程是最合适的。这种原则最常见的是`图像处理、算法处理`。
3. 数据共享，不同任务频繁需要通信。
4. 迅雷下载

**但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。**

#### ★☆☆ 进程状态

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e6%8f%8f%e8%bf%b0%e5%8f%8a%e7%bb%84%e7%bb%87%e6%96%b9%e5%bc%8f%f0%9f%98%80>)

![../../_img/具有挂起状态的进程状态图.jpg](../../_img/../../_img/具有挂起状态的进程状态图.jpg)

#### ★★★ 进程调度算法的特点以及使用场景

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6?id=_36-%e5%b8%b8%e7%94%a8%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95>)

**交互式系统中：**

1. 时间片轮转法
2. 优先级调度法：`动态优先级`,可以采用“论年头”的方法，即等待CPU很长时间的进程逐渐提升其优先级。时间片抢占。
3. 多级队列：把作业分别链入不同地队列，每个队列都由自己地调度算法
4. 多级反馈队列：高优先级队列的时间片小，低优先级队列的时间片大。新进程进入系统后，先放入第一队列的未尾，各队列按FCFS 方式排队；如某个进程在相应时间片内没有完成工作，则把它转到下一级队列的未尾；系统先运行第一队列中的进程，第一队列为空后才运行第二队列中的进程，以此类推， 最后一个队列（最低级）中的进程采用时间片轮转的方式进行调度。UNIX采用了类似的做法

**实时系统中：**

1. 实时调度算法

**批处理系统中：**

1. 先来先服务
2. 短作业优先
3. 最短剩余时间优先

#### ★☆☆ 线程实现的方式

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/操作系统/进程管理?id=线程的实现方式>)

主要有在`用户空间实现`和在`核心空间实现`两种实现方式。

**用户级线程：**

整个管理线程的`线程库`放在用户空间,核心对此一无所知。

**优点：**

1. 线程`切换速度很快`，无须进行系统调度。这比使用系统调用并陷入到核心去处理要快得多。
2. 调度算法可以是应用程序专用的。
3. 用户级线程可以运行在任何操作系统上，包括不支持线程机制的操作系统。

**缺点：**

1. 因为核心对此一无所知。当一个线程执行`系统调用`时，不仅它自已被阻塞，而且在同一个进程内的所有线程都被阻塞。
2. 在单纯用户级线程方式中，多线程应用程序`不具有多处理的优点`。因为核心只为每个进程一次分配一个处理器，每次只有该进程的一个线程得以执行，在该线程自愿放弃CPU 之前，该进程内的其他线程不会执行

**核心级线程：**

线程表在`核心空间中`。线程表中记载系统所有线程的情况，当一个线程想创建一个新线程或者删除一个现有线程时，`必须执行系统调用。`

**优点：**

1. 在多处理器系统中，核心可以同时调度同一进程的多个线程，真正实现并行操作
2. 如果一个进程的某个线程阻塞了，核心可以调度同一个进程的另一个线程
3. 核心线程本身也可以是多线程的

**缺点：**

1. 控制转移开销大。核心级线程方式都比用户级线程方式高一个数量级。

![用户空间和核心空间 (1).jpg](../../_img/用户空间和核心空间.jpg)

> [Linux的线程和进程](https://www.jianshu.com/p/5a4fc2729c17)

#### ★★☆ 协程的作用

> [协程有哪些好处-知乎](https://www.zhihu.com/question/20511233/answer/347651080)  
> [协程有哪些好处-知乎](https://www.zhihu.com/question/20511233)  
> [聊一聊协程-掘金](https://juejin.im/entry/5c3d88a8f265da61553b0ccd)

基本原理是：在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务；等完成或达到某个条件时，再还原原来栈信息并继续执行。【但是不是多线程】

```Ruby
call_sombody = Fiber.new do
  take_phone
  receive_call
  Fiber.yield
  speaking
  Fiber.yield
  shutdown
end

eat_cake = Fiber.new do
  take_cake
  open_box
  Fiber.yield
  taste
  Fiber.yield
  drop_box
end

call_somebody.resume // take_phone and receive_call then pause
eat_cake.resume // take_cake and open_box then pause
call_somebody.resume // speaking then pause
eat_cake.resume // taste then pause
call_somebody.resume // shutdown then pause
eat_cake.resume // dropbox then pause
```

执行起来大概是这样的：拿起电话、接听、拿蛋糕、开蛋糕盒、说话、吃蛋糕、挂机、扔蛋糕盒。yield 可以理解成为，做到这里，然后暂停一下，然后产出结果，等待上一个上下文对自己调度这样做有什么意义呢？多个协程协作好比就是你一个人其实同时只能做一件事，但是你`把几个任务拆成几截来交叉执行`。【这也是 JavaScript Promise Generator 的原理。】

协程解决的问题：`异步`！

上面几个点，可能大家会想到JVM的结构，栈，程序计数器等等，但是JVM原生是不支持这样的。如果在Java中需要使用协程的话，需要引入第三方包。

#### ★★☆ 常见进程同步问题

1. [生产者-消费者问题](https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_1-%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98)
2. [读者-写者问题（多个读者、写者）](https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_2-%e8%af%bb%e8%80%85-%e5%86%99%e8%80%85%e9%97%ae%e9%a2%98%e5%a4%9a%e4%b8%aa%e8%af%bb%e8%80%85%e3%80%81%e5%86%99%e8%80%85)
3. [哲学家进餐问题](https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_3-%e5%93%b2%e5%ad%a6%e5%ae%b6%e8%bf%9b%e9%a4%90%e9%97%ae%e9%a2%98)
4. [打瞌睡的理发师](https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_4-%e6%89%93%e7%9e%8c%e7%9d%a1%e7%9a%84%e7%90%86%e5%8f%91%e5%b8%88)

#### ★★★ 进程通信方法的特点以及使用场景

> [cyc: 进程通信](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1)  
> [floatLig: 进程通信](https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_27-%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1)

**1. 信号量：**

它是一个计数器，用于为多个进程提供`对共享数据对象的访问`。

**2. 管道：**

管道是通过pipe函数创建的，fd[0]用于读，fd[1]用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输）;
- 只能在`父子进程`或者`兄弟进程`中使用。

![53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png](../../_img/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png)

**3. FIFO：**

也命名为管道，去除了管道只能在父子进程总是使用的限制。

```c
#include <sys/stat.h>
int mkfifo<const char * path, mode_t mode>;
int mkfifoat(int fd, const char * paht, mode_t mode);
```

FIFO常用于`客户-服务器应用程序`中，FIFO用作汇聚点，`在客户进程和服务器进程之间传递数据`。

![操作系统面试1.png](../../_img/操作系统面试1.png)

**4. 消息队列：**

相比于FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难；
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型`有选择地接受消息`，而不像FIFO那样只能默认地接受。

**5. 共享存储：**

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是`最快`的一种IPC(进程通信)。

需要使用信号量来同步对共享存储的访问。

多个进程可以`将同一个文件映射到它们的地址空间`从而共享内存。

**6. 套接字：**

可以进行不同机器之间的通信。

#### ★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁

> [cyc: 银行家算法](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81)  

**1. 死锁的必要条件：**

- `互斥`：资源要么已经分配给了一个进程，要么就可以被其他进程使用
- `占有且申请`：一个进程占有一些资源，还可以再申请新的资源
- `不可抢占资源`：已经被占用的资源不能被其他进程抢占，只能被拥有该资源的进程显示释放
- `构成环路`：

**2. 处理方法：**

- `鸵鸟策略`

把头埋在沙子里，假装没有发生。

因为解决死锁的代价很高，所以采用鸵鸟策略以获得最高的性能。

当发生死锁对用户造成的`影响不大`，或者发生死锁的`概率很低`时，可以采用。

大多数操作系统，包括Linux，Unix，处理死锁的方法仅仅是忽略它。

- `死锁的检测与恢复`

不示图检测死锁，而是当死锁发生时，采取措施恢复。

死锁的恢复方法有：

```
    - 利用抢占恢复
    - 利用回滚恢复
    - 杀死进程
```

- `死锁的预防`

著名的有：银行家算法。

#### ★★★ 虚拟内存的作用，分页系统实现虚拟内存原理

虚拟内存是一个逻辑内存，可以让我们程序员写程序的时候，不用再担心实际的物理内存的大小，能够让我们的程序获得更多的内存空间。比如说，一个机器它是32位的话，它的内存空间最大就是4G。如果说是64位的话，内存空间最大是2^48B。

虚拟内存怎么实现的呢？

使用`分页系统`（[详细内容查看](https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86?id=_43-%e5%88%86%e9%a1%b5%e6%8a%80%e6%9c%af)）：

1. `逻辑空间分页`，每个页的大小一般是4KB。（[一个程序一个页表](https://blog.csdn.net/yangkuiwu/article/details/53166283)）
1. `物理地址空间分块（页框）`，每个块也是4KB。
1. 设立页表
1. 设立内存块表。
1. 再配合上快表。

使用`请求分页技术`，解决缺页问题。

#### ★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法

> [cyc: 页面置换算法](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86?id=%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95)

1. 最佳置换算法
2. 最近最久未使用
3. 最近未使用
4. 先进先出
5. 第二次机会算法
6. 时钟

#### ★★★ 比较分页与分段的区别

> [floatLig: 分段](https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86?id=%e5%88%86%e6%ae%b5%e6%8a%80%e6%9c%af)

用户希望把自己的程序按照`逻辑`关系组织，即划分成若干段。例如，有主程序段MAIN 、子程序段P 、数据段D和栈段S 等.

分页存储管理能够有效地提高`内存利用率`，而分段存储管理能够很好地`满足用户需要`。两者结合起来，就是`段页式存储管理系统`。

段页式存储管理系统怎么做呢？

1. 等分内存
2. 进程的地址空间（逻辑地址）采用分段方式
3. 段内分页
4. 逻辑地址的地址结构为：由段号s,页号p和页内地址d,记作v= (s,p,d)
5. 以内存块分配内存
6. 系统为每个进程建立一个段表，还要为每个段表建立一个页表。

这样既拥有`分段系统的共享和保护`，又拥有`分页系统的虚拟内存功能`。

#### ★★★ 分析静态链接的不足，以及动态链接的特点

### 2 Linux

#### ★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理

#### ★★★ 硬链接与软链接的区别

#### ★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk的作用

#### ★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因
