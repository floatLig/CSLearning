### 1. 基础

#### ★★★ 进程与线程的本质区别、以及各自的使用场景

> [参考链接](https://blog.csdn.net/baidu_37964044/article/details/81406866)

1. 一个进程可以有多个线程
2. 资源分配给进程，同一个进程的所有线程共享该进程的所有资源
3. CPU分派给线程，即真正在CPU上运行的是线程

**多进程的优点：**

1. `不用考虑锁和同步的问题`，编程相对容易。
2. `有更强的容错性`，如果一个进程崩溃了不会影响其他进程
3. 采用多进程程序一般可以做到一定程序的`自恢复`。【master守护进程监控所有worker进程，发现进程挂掉后将其重启】

**多线程的优势：**

1. `创建`速度快，方便高效的`共享数据`（共享内存，信号量等IPC技术）
2. `较轻的上下文切换`：不用切换地址空间，不用更改寄存器，不用刷新TLB快表
3. 提供非均质的服务：如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。

**多进程应用场景：**

1. nginx主流工作模式是多进程模式（也支持多线程模式）
2. 几乎所有的web server服务器都`有`多进程，至少有一个守护进程配合一个worker进程，例如apached，httpd等等以d结尾的进程。
3. chrome浏览器。（原因：一个网页如果不符合编程规范崩溃，不会影响其他进程；网页之间相互隔离，不用担心恶意代码获取其他网页敏感信息）
4. redis（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）

**多线程应用场景：**

1. `需要频繁创建销毁`的优先用线程（进程的创建和销毁开销过大）这种原则最常见的应用就是`Web服务器`了，`来一个连接建立一个线程`，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
2. 需要进行`大量计算`的优先使用线程（CPU频繁切换）所谓大量计算，当然就是要`耗费很多CPU`，切换频繁了，这种情况下线程是最合适的。这种原则最常见的是`图像处理、算法处理`。
3. 数据共享，不同任务频繁需要通信。
4. 迅雷下载

**但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。**

#### ★☆☆ 进程状态

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e6%8f%8f%e8%bf%b0%e5%8f%8a%e7%bb%84%e7%bb%87%e6%96%b9%e5%bc%8f%f0%9f%98%80>)

![../../_img/具有挂起状态的进程状态图.jpg](../../_img/../../_img/具有挂起状态的进程状态图.jpg)

#### ★★★ 进程调度算法的特点以及使用场景

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6?id=_36-%e5%b8%b8%e7%94%a8%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95>)

**交互式系统中：**

1. 时间片轮转法
2. 优先级调度法：`动态优先级`,可以采用“论年头”的方法，即等待CPU很长时间的进程逐渐提升其优先级。时间片抢占。
3. 多级队列：把作业分别链入不同地队列，每个队列都由自己地调度算法
4. 多级反馈队列：高优先级队列的时间片小，低优先级队列的时间片大。新进程进入系统后，先放入第一队列的未尾，各队列按FCFS 方式排队；如某个进程在相应时间片内没有完成工作，则把它转到下一级队列的未尾；系统先运行第一队列中的进程，第一队列为空后才运行第二队列中的进程，以此类推， 最后一个队列（最低级）中的进程采用时间片轮转的方式进行调度。UNIX采用了类似的做法

**实时系统中：**

1. 实时调度算法

**批处理系统中：**

1. 先来先服务
2. 短作业优先
3. 最短剩余时间优先

#### ★☆☆ 线程实现的方式

> [参考链接](<https://floatlig.github.io/JavaLearning/#/_source/操作系统/进程管理?id=线程的实现方式>)

主要有在`用户空间实现`和在`核心空间实现`两种实现方式。

**用户级线程：**

整个管理线程的`线程库`放在用户空间,核心对此一无所知。

**优点：**

1. 线程`切换速度很快`，无须进行系统调度。这比使用系统调用并陷入到核心去处理要快得多。
2. 调度算法可以是应用程序专用的。
3. 用户级线程可以运行在任何操作系统上，包括不支持线程机制的操作系统。

**缺点：**

1. 因为核心对此一无所知。当一个线程执行`系统调用`时，不仅它自已被阻塞，而且在同一个进程内的所有线程都被阻塞。
2. 在单纯用户级线程方式中，多线程应用程序`不具有多处理的优点`。因为核心只为每个进程一次分配一个处理器，每次只有该进程的一个线程得以执行，在该线程自愿放弃CPU 之前，该进程内的其他线程不会执行

**核心级线程：**

线程表在`核心空间中`。线程表中记载系统所有线程的情况，当一个线程想创建一个新线程或者删除一个现有线程时，`必须执行系统调用。`

**优点：**

1. 在多处理器系统中，核心可以同时调度同一进程的多个线程，真正实现并行操作
2. 如果一个进程的某个线程阻塞了，核心可以调度同一个进程的另一个线程
3. 核心线程本身也可以是多线程的

**缺点：**

1. 控制转移开销大。核心级线程方式都比用户级线程方式高一个数量级。

![用户空间和核心空间 (1).jpg](../../_img/用户空间和核心空间.jpg)

> [Linux的线程和进程](https://www.jianshu.com/p/5a4fc2729c17)

#### ★★☆ 协程的作用

基本原理是：在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务；等完成或达到某个条件时，再还原原来栈信息并继续执行。【但是不是多线程】

```Ruby
call_sombody = Fiber.new do
  take_phone
  receive_call
  Fiber.yield
  speaking
  Fiber.yield
  shutdown
end

eat_cake = Fiber.new do
  take_cake
  open_box
  Fiber.yield
  taste
  Fiber.yield
  drop_box
end

call_somebody.resume // take_phone and receive_call then pause
eat_cake.resume // take_cake and open_box then pause
call_somebody.resume // speaking then pause
eat_cake.resume // taste then pause
call_somebody.resume // shutdown then pause
eat_cake.resume // dropbox then pause
```

执行起来大概是这样的：拿起电话、接听、拿蛋糕、开蛋糕盒、说话、吃蛋糕、挂机、扔蛋糕盒。yield 可以理解成为，做到这里，然后暂停一下，然后产出结果，等待上一个上下文对自己调度这样做有什么意义呢？多个协程协作好比就是你一个人其实同时只能做一件事，但是你`把几个任务拆成几截来交叉执行`。【这也是 JavaScript Promise Generator 的原理。】

协程解决的问题：`异步`！

上面几个点，可能大家会想到JVM的结构，栈，程序计数器等等，但是JVM原生是不支持这样的。如果在Java中需要使用协程的话，需要引入第三方包。

> [协程有哪些好处-知乎](https://www.zhihu.com/question/20511233/answer/347651080)  
> [协程有哪些好处-知乎](https://www.zhihu.com/question/20511233)  
> [聊一聊协程-掘金](https://juejin.im/entry/5c3d88a8f265da61553b0ccd)

#### ★★☆ 常见进程同步问题



#### ★★★ 进程通信方法的特点以及使用场景



#### ★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁



#### ★★★ 虚拟内存的作用，分页系统实现虚拟内存原理



#### ★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法



#### ★★★ 比较分页与分段的区别



#### ★★★ 分析静态链接的不足，以及动态链接的特点



### 2 Linu



#### ★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理



#### ★★★ 硬链接与软链接的区别



#### ★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk的作用


#### ★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因


