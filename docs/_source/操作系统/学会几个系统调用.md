## 学会几个系统调用

Linux可以理解为是一个很大的程序，如果其他的程序想要Linux提供服务，那么就需要进行系统调用。系统调用决定了Linux好不好用，功能全不全，现在我们来看一下，Linux系统能提供哪些服务。

### 进程管理

首先，进行`进程管理`的话，肯定是需要要包括`创建`一个子进程。

创建进程的`系统调用叫fork`。在 Linux 里，要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作`父进程`（Parent Process），新的进程叫作`子进程`（Child Process）。

但是一个进程需要很多东西，比如内存，执行什么程序，有什么数据等等。Linux如果解决这个问题呢？

当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。

对于 fork 系统调用的`返回值`，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就`有了一个区分`，然后通过 if-else 语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求`另一个系统调用execve`来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。

有时候，`父进程要关心子进程的运行情况`，这毕竟是自己身上掉下来的肉。有个系统调用`waitpid`，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

### 内存管理

在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的`进程内存空间`。

进程在自己的内存空间中，能看到什么？进程在自己的内存空间中，可以看到代码段、数据段、堆栈段等。

这里我们介绍两个在`堆里面分配内存的系统调用，brk和mmap。`

当分配的内存数量比较小的时候，使用 `brk`，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用 `mmap`，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

### 文件管理

文件存储要考虑：一方面是介质，另一方面是格式。

文件管理其实花样不多，拍着脑袋都能想出来，无非是创建、打开、读、写等。

- 对于已经有的文件，可以使用`open`打开这个文件，`close`关闭这个文件；
- 对于没有的文件，可以使用`creat`创建文件；
- 打开文件以后，可以使用`lseek`跳到文件的某个位置；
- 可以对文件的内容进行读写，读的系统调用是`read`，写是`write`。

但是别忘了，Linux 里有一个特点，那就是`一切皆文件`。

- 启动一个进程，需要一个程序文件，这是一个`二进制文件`。
- 启动的时候，要加载一些配置文件，例如 yml、properties 等，这是文本文件；启动之后会打印一些日志，如果写到硬盘上，也是`文本文件`。
- 但是如果我想把日志打印到交互控制台上，在命令行上唰唰地打印出来，这其实也是一个文件，是`标准输出 stdout 文件`。
- 这个进程的输出可以作为另一个进程的输入，这种方式称为管道，`管道也是一个文件`。
- 进程可以通过网络和其他进程进行通信，建立的 `Socket，也是一个文件`。
- 进程需要访问外部设备，`设备也是一个文件`。
- 文件都被存储在文件夹里面，其实`文件夹也是一个文件`。
- 进程运行起来，要想看到`进程`运行的情况，会在 `/proc` 下面有对应的进程号，还是一系列文件。

每个文件，Linux 都会分配一个`文件描述符（File Descriptor）`，这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。所以说，文件操作是贯穿始终的，这也是“一切皆文件”的优势，就是统一了操作的入口，提供了极大的便利。

### 信号处理

在项目运行过程中，不一定都是一帆风顺的，很可能遇到各种异常情况。

当项目遇到异常情况，例如项目中断，做到一半不做了。这时候就需要发送一个`信号（Signal）`给项目组。经常遇到的信号有以下几种：

- 在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；
- 如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；
- 硬件故障，设备出了问题，当然要通知项目组；
- 用户进程通过kill函数，将一个用户信号发送给另一个进程。

当项目组收到信号的时候，项目组需要决定如何处理这些异常情况。

对于一些不严重的信号，可以忽略，该干啥干啥，但是像 `SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的`，可以执行对于该信号的默认动作。每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供`信号处理函数`，可以通过`sigaction系统调用，注册一个信号处理函数`。

### 进程间通信

**消息队列:**

这个消息队列是在内核里的，我们可以通过`msgget`创建一个新的队列，`msgsnd`将消息发送到消息队列，而消息接收方可以使用`msgrcv`从队列中取消息。

当两个项目组需要交互的信息比较大的时候，可以使用`共享内存`的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。大家都到这个会议室来，就可以完成沟通了。这时候，我们可以通过`shmget`创建一个共享内存块，通过`shmat将共享内存映射到自己的内存空间`，然后就可以读写了。

因为是共享内存，所以可能会存在“竞争”的情况，所以需要`信号量的机制 Semaphore`来保证数据的正确访问。

### 网络通信

我们可以通过 Socket 系统调用建立一个 Socket。Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。

### 查看系统调用的源代码

对于 64 位操作系统，找到 unistd_64.h 文件，里面对于系统调用的定义，就是下面这样。

```c
#define __NR_restart_syscall    0
#define __NR_exit      1
#define __NR_fork      2
#define __NR_read      3
#define __NR_write      4
#define __NR_open      5
#define __NR_close      6
#define __NR_waitpid      7
#define __NR_creat      8
......
```

更多的系统调用，可以通过[这里](https://github.com/torvalds/linux/blob/master/arch/sh/include/uapi/asm/unistd_64.h)查看

> 这里还推荐两个查看Linux源码的网站：  
> <https://elixir.bootlin.com/linux/v4.0/source/kernel>  
> <https://github.com/torvalds/linux>

### 中介与 Glibc

平时我们在开发时并不会直接使用系统调用。这是因为为了

对用户更友好，我们可以使用中介 `Glibc`，有事情找它就行，它会转换成为系统调用，帮你调用。

Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。

每个特定的系统调用对应了至少一个 Glibc 封装的库函数，比如说，系统提供的打开文件系统调用 sys_open 对应的是 Glibc 中的 open 函数。

有时候，Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。

也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。

### 总结

![ffb6847b94cb0fd086095ac263ac4ff0.jpg](../../_img/ffb6847b94cb0fd086095ac263ac4ff0.jpg)

有个命令 strace，常用来跟踪进程执行时系统调用和所接收的信号。

```bash
strace ls -la
```

### 参考链接

[极客时间-趣谈Linux操作系统](https://time.geekbang.org/column/article/89251)