> Java 8中文版-在线API：<http://www.matools.com/api/java8>

## InetAddress

`Java.net`包下的`InetAddress`类，表示**Interner协议（IP）地址**，InetAddress类的常用方法如下：

```java
    //InetAddress: 此类表示Internet协议（IP）地址。
    InetAddress addr = InetAddress.getLocalHost();
    System.out.println(addr.getHostAddress());  //返回：192.168.1.110
    System.out.println(addr.getHostName());  //输出计算机名:Zzl

    //根据域名得到InetAddress对象
    addr = InetAddress.getByName("www.shsxt.com");
    System.out.println(addr.getHostAddress());  //返回 shsxt服务器的ip:123.56.138.186
    System.out.println(addr.getHostName());  //输出：www.shsxt.com

    //根据ip得到InetAddress对象
    addr = InetAddress.getByName("123.56.138.176");
    System.out.println(addr.getHostAddress());  //返回 shsxt的ip:123.56.138.176
    System.out.println(addr.getHostName());  //输出ip而不是域名。如果这个IP地 址不存在或DNS服务器不允许进行IP地址和域名的映射
```

## InetSocketAddress

`Java.net`包下的`InetSocketAddress`类，该类实现IP套接字地址（IP地址+端口号）它也可以是一对（主机名+端口号），InetSocketAddress类的常用方法如下：

```java
    //包含端口
    InetSocketAddress socketAddress = new InetSocketAddress("127.0.0.1",8080);
    InetSocketAddress socketAddress2 = new InetSocketAddress("localhost",9000);
    System.out.println(socketAddress.getHostName());//127.0.0.1
    System.out.println(socketAddress.getAddress());//127.0.0.1/127.0.0.1 (第一个为IP的原因为：获取不到getHostName,只能通过IP表示)
    System.out.println(socketAddress2.getAddress());//localhost/127.0.0.1
    System.out.println(socketAddress2.getPort());//9000
```

## URL

```java
    URL url = new URL("http://www.baidu.com:80/index.html?uname=shsxt&age=18#a");
    //获取四个值
    System.out.println("协议:"+url.getProtocol());//协议:http
    System.out.println("域名|ip:"+url.getHost());//域名|ip:www.baidu.com
    System.out.println("端口:"+url.getPort());//端口:80
    System.out.println("请求资源1:"+url.getFile());//请求资源1:/index.html?uname=shsxt&age=18
    System.out.println("请求资源2:"+url.getPath());//请求资源2:/index.html

    //参数
    System.out.println("参数:"+url.getQuery());//参数:uname=shsxt&age=18
    //锚点
    System.out.println("锚点:"+url.getRef());//锚点:a
```

## 爬取网页源代码

```java
    //获取URL
    URL url =new URL("https://www.jd.com");

    //下载资源
    InputStream is = url.openStream();
    BufferedReader br =new BufferedReader(new InputStreamReader(is,"UTF-8"));
    String msg =null;
    while(null != (msg=br.readLine())) {
        System.out.println(msg);
    }
    br.close();
    //分析
    //处理。。。。
```

如果说，网站限制你不能直接爬取，那么你可以模仿发送请求的方法

```java
    //获取URL
    URL url =new URL("https://www.dianping.com");

    //下载资源；直接爬取大众点评网爬取不了，可以通过模拟浏览器登陆的方式爬取网站源码
    HttpURLConnection  conn =(HttpURLConnection) url.openConnection();
    conn.setRequestMethod("GET");
    conn.setRequestProperty("User-Agent","Mozilla/5.0 (Windows NT 10.0; Win64; x64)
     AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36");

    BufferedReader br =new BufferedReader(new InputStreamReader(conn.getInputStream(),"UTF-8"));
    String msg =null;
    while(null != (msg=br.readLine())) {
        System.out.println(msg);
    }
    br.close();
    //分析
    //处理。。。。
```

## UDP

`Java.net.DatagramSocket类`：该类表示用于**发送和接收数据包**的套接字。

### UDP最基础写法

`UdpClient`类如下：

```java
    System.out.println("发送方启动中.....");

    // 1、使用DatagramSocket  指定端口 创建UDP发送端
    DatagramSocket client =new DatagramSocket(8888);
    //2、准备数据 要转成字节数组，因为Upd传送的字节数组
    String data = "上海尚学堂";
    byte[] datas = data.getBytes();
    //3、 封装成DatagramPacket 包裹，该包裹存放要发送信息的字节数组，并由目的地址
    DatagramPacket packet =new DatagramPacket(datas,0,datas.length,
            new InetSocketAddress("localhost",6666));
    //4、发送包裹send​(DatagramPacket p)
    client.send(packet);
    // 5、释放资源
    client.close();
```

`UdpServer`类如下:

```java
    System.out.println("接收方启动中.....");

    // 1、使用DatagramSocket  指定端口 创建UDP接收端（发送端和接收端端口不能一样）
    DatagramSocket server =new DatagramSocket(6666);
    // 2、准备容器 封装成DatagramPacket 包裹，用该包裹接收
    byte[] container =new byte[1024*60];
    DatagramPacket packet = new DatagramPacket(container,0,container.length);
    // 3、阻塞式接收包裹receive​(DatagramPacket p)
    server.receive(packet); //阻塞式
    // 4、分析数据
    byte[]  datas =packet.getData();
    int len = packet.getLength();
    //转成string
    System.out.println(new String(datas,0,len));
    // 5、释放资源
    server.close();
```

### UDP教师、学生聊天室

这里发送和接收-->`发送线程`和`接收线程`，老师类和学生类分别加载使用这个两个线程

`TalkTeacher`类如下:

```java
public static void main(String[] args) {
    //接收线程：9999为TalkTeacher接收的端口号；"学生"是对方的标识符
    new Thread(new TalkReceive(9999,"学生")).start();
    //发送线程：5555为TalkTeacher发送的端口号，"localhost",8888是目的地
    new Thread(new TalkSend(5555,"localhost",8888)).start();
}
```

`TalkStudent`类如下

```java
public static void main(String[] args) {
    //发送线程：7777为TalkStudent发送的端口号，"localhost",9999是目的地
    new Thread(new TalkSend(7777,"localhost",9999)).start();
    //接收线程：8888为TalkStudent接收的端口号；"老师"是对方的标识符
    new Thread(new TalkReceive(8888,"老师")).start();
}
```

`TalkSend`类如下

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

/**
 * 发送端: 使用面向对象封装
 *
 * @author 裴新 QQ:3401997271
 *
 */
public class TalkSend implements Runnable {
    /**
	 * 自己发送端的DatagramSocket
	 */
	private DatagramSocket client ;
	/**
	 * 发送端的输入流，从控制台读取
	 */
	private BufferedReader reader;
	/**
	 * 发送包裹的目的地址
	 */
	private String toIP ;
	/**
	 * 发送包裹的目的端口
	 */
	private int toPort ;

	public TalkSend(int port,String toIP,int toPort) {
		this.toIP = toIP;
		this.toPort=toPort;
		try {
			client=new DatagramSocket(port);
			reader =new BufferedReader(new InputStreamReader(System.in));
		} catch (SocketException e) {
            e.printStackTrace();
		}
	}

	@Override
	public void run() {
		//发送线程，一直在运行，只有等到输入“bye”才结束发送线程的运行
		while(true) {
			String data;
			try {
				//从控制台输入
				data = reader.readLine();
				//3、 封装成DatagramPacket 包裹，需要指定目的地
				byte[] datas = data.getBytes();
				DatagramPacket packet =new DatagramPacket(datas,0,datas.length,
						new InetSocketAddress(this.toIP,this.toPort));
				//4、发送包裹send​(DatagramPacket p) *
				client.send(packet);
				//如果发送的消息是“bye”，则结束发送线程的运行
				if(data.equals("bye")) {
					break;
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		// 5、释放资源
        client.close();
	}
}
```

`TalkReceive`类如下

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

/**
 * 接收端: 使用面向对象封装
 *
 * @author 裴新 QQ:3401997271
 *
 */
public class TalkReceive implements Runnable {
	/**
	 * 接收端的端口号
	 */
	private DatagramSocket server ;
	/**
	 * 对方的标识符
	 */
	private String from ;

	/**
	 * 构造函数
	 * @param port 接收端的端口号
	 * @param from 对方的标识符
	 */
	public TalkReceive(int port,String from) {
		this.from = from ;
		try {
			server=new DatagramSocket(port);
		} catch (SocketException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void run() {
		while(true) {
			// 2、准备容器 封装成DatagramPacket 包裹
			byte[] container =new byte[1024*60];
			DatagramPacket packet = new DatagramPacket(container,0,container.length);
			// 3、阻塞式接收包裹receive​(DatagramPacket p)
			try {
				server.receive(packet);//阻塞式
				// 4、分析数据
				 byte[]  datas =packet.getData();
				 int len = packet.getLength();
				 String data=new String(datas,0,len);
				 System.out.println(from+":"+data);
				 if(data.equals("bye")) {
					 break;
				 }
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		// 5、释放资源
		 server.close();
	}
}
```
