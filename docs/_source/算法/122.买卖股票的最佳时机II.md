## 题目链接

[122\. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

## 题目描述

Difficulty: **简单**

给定一个数组，它的第 _i_ 个元素是一支给定股票第 _i_ 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

## Solution

### 贪心

`要建立正确的模型，然后使用逻辑去写出这个模型。`

![leetcode122.png](../../_img/leetcode122.png)

买卖股票的最佳时机是什么，低价买进，高价卖出。那么问题就转换为只要有低价的时候就买进，只要出现高价的时候就卖出。

那买进怎么判断，`prices[i] < prices[i + 1]`，因为题目又说了，不能连续购买股票，所以，买进的时候是`buy 为 null（-1）`的。

那卖出怎么判断，当`prices[i + 1] < prices[i]`且`buy不为null（-1）`时。当然，当最后一天的时候如果持有股票也是卖出去的（最后一天持有股票说明股票是涨，只要一跌，我们就在之前卖出去了），那怎么判断最后一天且持有股票呢?`i == prices.length - 2 && buy != -1`。

Language: **Java**

```java
​class Solution {
    public int maxProfit(int[] prices) {
        int buy = -1;
        int profit = 0;

        for(int i = 0; i < prices.length - 1; i++){
            //买进
            if(prices[i] < prices[i + 1] && buy == -1){
                buy = prices[i];
            }else if(prices[i] > prices[i + 1] && buy != -1){
                //跌了立马卖出去
                profit += prices[i] - buy;
                buy = -1;
            }
            //注意这里的if要单独起行，因为这个是判断是不是price.length - 2的，和前面的买进有可能不互斥。
            if(i == prices.length - 2 && buy != -1){
                //如果i == prices.length - 2时，
                //prices.length - 1如果比prices.length - 2小，那么应该前面的判断会卖出
                //当prices.length - 1比prices.length - 2大，那么应该在这里卖出
                profit += prices[prices.length - 1] - buy;
                buy = -1;
            }
        }
        return profit;
    }
}
```

一种转换的贪心

```java
class Solution {

    public int maxProfit(int[] prices) {
        int res = 0;

        for(int i = 0; i < prices.length - 1; i++){
            if(prices[i] < prices[i + 1]){
                res += prices[i + 1] - prices[i];
            }
        }

        return res;
    }

}
```

还有一种走哪算到哪儿的解法.

使用while可以i++后继续进行操作。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;

        int peek = prices[0];
        int valley = prices[0];
        int profit = 0;

        int i = 0;
        while(i < prices.length - 1){
            //跌的不买
            while(i < prices.length - 1 && prices[i] >= prices[i + 1]){
                i++;
            }
            valley = prices[i];
            //涨的不卖
            while(i < prices.length - 1 && prices[i] <= prices[i + 1]){
                //如果是倒数第二个数，它仍会++
                i++;
            }
            peek = prices[i];
            profit += peek - valley;
        }

        return profit;
    }
}
```
 