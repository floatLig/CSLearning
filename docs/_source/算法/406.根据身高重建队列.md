# 406. 根据身高重建队列

## 题目链接

[406\. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

## 题目描述

Difficulty: **中等**

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对`(h, k)`表示，其中`h`是这个人的身高，`k`是排在这个人前面且身高大于或等于`h`的人数。 编写一个算法来重建这个队列。

**注意：**  
总人数少于1100人。

**示例：**

```
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

## Solution

1. 假设数据是[[7,1], [7,0]]，排序后的顺序是[[7, 0], [7, 1]]。 排序的规则为：如果是相同身高的（h相同），那么k即为排序后的索引。
2. 如果这个时候有更矮的人[6, 1]进来，那么他的位置也是下标k的位置（[6, 1]的k 为 1）。即新加入元素后，排序为[[7, 0], [6, 1], [7, 1]]。为什么可以这么说呢，`因为[7, 1]中的1，只有大于等于7才有影响，无论有多矮的人插在[7, 1]前面，[7, 1]都是正确的`
3. 所以，对于我们这道题，我们的排序可以为：`先对身高从高到低排序，如果是同身高的，再按照下标值k 从小到大排序`。
4. 排序往后，我们就重新改变位置。遍历排好序的数组，按照k插到对应的位置。

Language: **Java**

```java
​class Solution {
    public int[][] reconstructQueue(int[][] people) {
        //排序
        Arrays.sort(people, (o1, o2) -> (o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]));

        //根据k的位置，重新更新位置
        LinkedList<int[]> list = new LinkedList<>();
        for (int[] p : people){
            list.add(p[1], p);
        }

        //把链表转成数组
        list.toArray(people);
        return people;
    }
}
```