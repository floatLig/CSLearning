# 912. 排序数组

## 题目链接

[912\. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

## 题目描述

Difficulty: **中等**

给定一个整数数组 `nums`，将该数组升序排列。

**示例 1：**

```
输入：[5,2,3,1]
输出：[1,2,3,5]
```

**示例 2：**

```
输入：[5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

**提示：**

1. `1 <= A.length <= 10000`
2. `-50000 <= A[i] <= 50000`

## Solution

排序学的还不是很好，后面再多看看[weiwei的题解](https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/)。

Language: **Java**

### 归并排序

切分数组, 一分为二，从最大切分到最小；合并，从最小合并到最大

```java
class Solution {
    public int[] sortArray(int[] nums) {
        divide(nums, 0, nums.length - 1);
        return nums;
    }

    //切分数组
    private void divide(int[] nums, int left, int right){
        if (left >= right) return;

        //一分为二，从最大切分到最小
        int mid = (left + right) / 2;
        divide(nums, left, mid);
        divide(nums, mid + 1, right);
        //合并，从最小合并到最大
        merge(nums, left, mid, right);
    }

    //合并
    private void merge(int[] nums, int left, int mid, int right){
        //两个指针，分别指向【被切分块】的起始位置
        int i = left, j = mid + 1;
        //用一个数组来存储重新合并的数据
        int[] temp = new int[right - left + 1];
        int index = 0;
        while (i <= mid && j <= right){
            // <= 保证是稳定排序
            if (nums[i] <= nums[j]){
                temp[index++] = nums[i++];
            }else {
                temp[index++] = nums[j++];
            }
        }
        while (i <= mid){
            temp[index++] = nums[i++];
        }
        while (j <= right){
            temp[index++] = nums[j++];
        }
        //合并到原数组
        index = left;
        for (i = 0; i < temp.length; i++){
            nums[left++] = temp[i];
        }
    }
}
```

### 快速排序

同样是递归, 只不过切分的位置找特定的位置，而不是简简单单的一分为二

```java
​class Solution {
    public int[] sortArray(int[] nums) {
        sort(nums, 0, nums.length - 1);
        return nums;
    }

    //同样是递归
    private void sort(int[] nums, int lo, int hi){
        if (lo >= hi) return;

        //只不过切分的位置找特定的位置，而不是简简单单的一分为二
        int j = partition(nums, lo, hi);
        sort(nums, lo, j - 1);
        sort(nums, j + 1, hi);
    }

    private int partition(int[] nums, int lo, int hi){
        int temp = nums[lo];
        //lo，hi + 1都是无效的点，函数在开始循环时是++i 和 --j
        int i = lo, j = hi + 1;
        while (true){
            //在这个过程中，将比nums[lo]小的数据移到左边，将比nums[lo]大的数据移到右边
            while(i != hi && nums[++i] < temp);
            while(j != lo && nums[--j] > temp);
            if (i >= j) break;
            swap(nums, i, j);
        }
        swap(nums, lo, j);
        return j;
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### 插入排序

很像我们玩扑克牌的插入

1. `大型的 swap`： int temp = nums[i]; // 多次交换 nums[j] = nums[j - 1]; nums[i] = temp;

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        //从第 1 ~ 第 len - 1开始选择插入
        for (int i = 1; i < len; i++){
            //暂存数据
      int temp = nums[i];
            int j = i;
            //大于temp的值，都往后挪一格
            while (j > 0 && nums[j - 1] > temp){
                nums[j] = nums[j - 1];
                j--;
            }
            nums[j] = temp;
        }
        return nums;
    }
}
```

### 冒泡排序

```java
public int[] sortArray(int[] nums) {
        if (nums == null || nums.length == 0){
            return nums;
        }
        boolean flag = true;
        for (int i = nums.length - 1; i >= 1; i--){
            for (int j = 0; j < i; j++){
                //这里前往注意，比较的是j + 1，而不是j++
                if (nums[j] > nums[j + 1]){
                    flag = false;
                    int temp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = temp;
                }
            }
            if (flag == true){
                break;
            }else {
                flag = true;
            }
        }
        return nums;
    }
```

### 堆排序

1. for --> `i--`
2. 最大堆和最小堆只用改2个符号就可以
3. heapify 是 构建一个堆


```java
public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 初始化堆
        // 堆是完全二叉树，所以可以用数组表示，且父子结点之间有规律
        // 父节点的值 > 孩子结点的值，通过 shiftDown() 函数满足这个条件
        heapify(nums);

        for (int i = len - 1; i >= 1; i--) {
            // 交换 并 shiftDown()
            swap(nums, 0, i);
            shiftDown(nums, 0, i - 1);
        }
        return nums;
    }

    private void heapify(int[] nums) {
        int len = nums.length;
        for (int i = (len - 1) / 2; i >= 0; i--) {
            // 一半的结点进行 shiftDown()
            shiftDown(nums, i, len - 1);
        }
    }

    private void shiftDown(int[] nums, int k, int end) {
        // 特值判定
        if (k < 0 || k > end || end > nums.length) {
            return;
        }
        // 左孩子节点的下标
        while (2 * k + 1 <= end) {
            // 左孩子 son
            int s = 2 * k + 1;
            // 这里是最大堆，如果右孩子的结点比较大，则 s 指向的位置为 右孩子结点下标 s + 1
            // ---->  如果求得是最小堆， 则 nums[s + 1] < nums[s]
            if (s + 1 <= end && nums[s + 1] > nums[s]) {
                s++;
            }
            // 如果孩子结点的值 > 父节点的值，进行交换
            // ---->  如果是最小堆， 则 nums[s] < nums[k]。最大堆，最小堆，只要改这两处就可以了！！
            if (nums[s] > nums[k]) {
                swap(nums, s, k);
            } else {
                // 记得要break
                break;
            }
            // 新的父节点
            k = s;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

API： 

```java

// 最小堆
PriorityQueue<Integer> pq = new PriorityQueue((o1, o2) -> map.get(o1) - map.get(o2));

// 最大堆
PriorityQueue<Integer> pq = new PriorityQueue((o1, o2) -> o2 - o1);
```