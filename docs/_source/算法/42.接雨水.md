# 42. 接雨水

## 题目链接

[42\. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

Difficulty: **困难**

给定 _n_ 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![rainwatertrap](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

<small style="display: inline;">上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。</small>

**示例:**

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

## Solution

> [优秀题解](<https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/>)

Language: **Java**

### 按行遍历

```java
​int left = 0, right = height.length - 1;
        int max = -1;
        int res = 0;
        //因为你是要一层一层的遍历，所以需要找到最大值
        for (int i : height) {
            max = Math.max(i, max);
        }

        //一层一层的遍历
        for (int floor = 1; floor <= max; floor++){
            left = 0;
            right = height.length - 1;
            //找到每一层的范围
            while (height[left] < floor) left++;
            while (height[right] < floor) right--;
            //在这个范围内，只有有空的，就一定会有水，仔细品品这句话
            while (left != right){
                left++;
                if(height[left] < floor) res++;
            }
        }
        return res;
```

### 按列遍历

```java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        int left = 0;
        int leftMax = -1;
        int rightMax = -1;
        rightMax = getRightMax(0, height);

        //left右边有right，left到达的最右边是height.length - 2, right到达的最右边是height.length - 1
        //判断的是left + 1这一列的水
        while (left + 1 < height.length){
            leftMax = Math.max(leftMax, height[left]);
            if(height[left] == rightMax){
                rightMax = getRightMax(left, height);
            }

            int minHeight = Math.min(leftMax, rightMax);
            res += minHeight > height[left + 1] ? (minHeight - height[left + 1]) : 0;
            left++;
        }
        return res;
    }

    /**
     * 获取right的最大值。这里最大值是不包括left这个值的
     *
     * 这里需要保证left + 1不会越界
     */
    private int getRightMax(int left, int[] height){
        int max = -1;
        for(int i = left + 1; i < height.length; i++){
            max = Math.max(height[i], max);
        }
        return max;
    }
}
```

### 列的优化

```java
class Solution {
public int trap(int[] height) {
    int res = 0;
        //将要被决策的位置
        int left = 1;
        int right = height.length - 2;
        int minMax = -1;

        //遍数
        for(int i = 1; i < height.length - 1; i++){
            //这道题求某一列的水的思路为：先求出这一列左边最高的墙，再求出这一列右边最高的墙，两座墙较矮的便是这一列水能达到最高的位置
            //上面那种思路，求右边最高的墙，其实还是要遍历一遍的。上面的这种思路还可以优化：
            //先找到是左边墙较低，还是右边墙较低，如果是左边墙较低，则找出左边最高的墙；如果是右边墙较低，则找出右边最高的墙
            if(height[left - 1] < height[right + 1]){
                minMax = Math.max(minMax, height[left - 1]);
                if(minMax - height[left] > 0){
                    res += minMax - height[left];
                }
                left++;
            }else {
                minMax = Math.max(minMax, height[right + 1]);
                if(minMax - height[right] > 0){
                    res += minMax - height[right];
                }
                right--;
            }
        }
        return res;
    }
}
```