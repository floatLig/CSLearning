# 146. LRU缓存机制

## 题目链接

[146\. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

## 题目描述

Difficulty: **中等**

运用你所掌握的数据结构，设计和实现一个  。它应该支持以下操作： 获取数据 `get` 和 写入数据 `put` 。

获取数据 `get(key)` - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。  
写入数据 `put(key, value)` - 如果密钥不存在，则写入（设置或插入）其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**进阶:**

你是否可以在 **O(1)** 时间复杂度内完成这两种操作？

**示例:**

```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

## Solution

Language: **Java**

```java
​
class LRUCache {

    static class DoubleList {
        private int key;
        private int value;
        private DoubleList pre;
        private DoubleList next;

        public DoubleList(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private Map<Integer, DoubleList> nodeMap;

    private DoubleList cache;
    private DoubleList dummyTail;

    private int capacity;

    public LRUCache(int capacity) {
        nodeMap = new HashMap<>(capacity);
        //头结点
        // null <-- cache <---->  dummyTail --> null
        cache = new DoubleList(-1, -1);
        dummyTail = new DoubleList(-1, -1);
        cache.next = dummyTail;
        cache.pre = null;
        dummyTail.pre = cache;
        dummyTail.next = null;

        this.capacity = capacity;
    }

    public int get(int key) {
        if (!nodeMap.containsKey(key)) {
            return -1;
        } else {
            DoubleList node = nodeMap.get(key);
            //从链表中把该结点删除
            removeNode(node);

            //再重新把该结点查到cache的最前面
            add2Head(node);

            return node.value;
        }
    }

    private void removeNode(DoubleList node) {
        // pre <--> node <--> next  ====》  pre <--> next
        node.pre.next = node.next;
        node.next.pre = node.pre;
        //置空，等待被GC回收
        node.pre = null;
        node.next = null;
    }

    private void add2Head(DoubleList node) {
        // cache <--> next ===》 cache <--> node <--> next
        node.pre = cache;
        node.next = cache.next;
        cache.next.pre = node;
        cache.next = node;
    }

    public void put(int key, int value) {
        //有存在相同的key，更新
        if (nodeMap.containsKey(key)) {
            DoubleList node = nodeMap.get(key);
            //更新数据
            node.value = value;
            //更新map的数据
            nodeMap.put(key, node);
            //更新cache的顺序
            removeNode(node);
            add2Head(node);
        } else {
            //如果不存在key， 且结点数量到达capacity，删除最近最久未使用的结点[cache的最后一个结点]，再插入新的结点
            if (nodeMap.size() == capacity) {
                //从链表中删除结点
                int removeKey = removeLast();
                //从nodeMap中删除结点
                nodeMap.remove(removeKey);
            }
            //插入新节点
            DoubleList node = new DoubleList(key, value);
            nodeMap.put(key, node);
            add2Head(node);
        }
    }

    //返回被删除结点的key
    private int removeLast(){
        // pre <--> lastNode <--> dummyTail ===》 pre <--> dummyTail
        DoubleList lastNode = dummyTail.pre;
        lastNode.pre.next = lastNode.next;
        lastNode.next.pre = lastNode.pre;
        lastNode.next = null;
        lastNode.pre = null;
        return lastNode.key;
    }
}

```