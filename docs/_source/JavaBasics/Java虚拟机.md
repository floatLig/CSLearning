## Java 虚拟机

### 运行时的数据区域

![jvm1.jpg](../../_img/jvm1.jpg)

### 程序计数器

记录正在执行的虚拟机字节码**指令**的地址（如果正在执行的是本地方法则为空）

### Java虚拟机栈

每个`Java方法`在执行的同时会创建`一个栈帧`用于存储`局部变量表、操作数栈、常量池引用`等信息。从方法调用直至执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。

![jvm1.jpg](../../_img/jvm02.png)

!> 命令执行错误，原因未找到

可以通过`-Xss`这个虚拟机参数来指定每个线程的Java虚拟机`栈的内存大小`，在JDK 1.4中默认为256K，而在JDK 1.5+中默认为1M：

```
java -Xss2M HackTheJava
```

该区域可能抛出以下异常：

- 当线程请求的`栈深度`超过最大值，会抛出`StackOverflowError`异常；
- 栈进行`动态扩展`时如果`无法申请到足够内存，`会抛出`OutOfMemoryError`异常。

### 本地方法栈

本地方法栈与Java虚拟机栈类似，它们之间的区别只不过本地方法栈是为本地方法服务的。

本地方法一般是用其他语言`（C、C++或汇编语言等）`编写的，并且被编译为`基于本地硬件和操作系统的程序`，对待这些方法需要特别处理。

![jvm03.jpg](../../_img/jvm3.png)

### 堆

所有对象都在这里分配内存，是垃圾回收的主要区域（“GC堆”）

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分为两块：

- 新生代（Young Generation）
- 老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出OutOfMemoryError异常。

可以通过`- Xms`和`- Xmx`这两个虚拟机参数来指定一个程序的`堆内存大小`，第一个参数设置初始值，第二个参数设置最大值。

```
java -Xms1M -Xmx2M HackTheJava
```

### 方法区

用于存放`已被加载的类信息、常量、静态变量、即时编译器编译后的代码`等数据。

方法区是一个JVM规范，永久代与元空间都是其一种实现方式。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。这块区域进行垃圾回收的主要目标是`对常量池的回收`和`对类的卸载`，但是一般比较难实现。

在JDK 1.8之前，把它当成永久代来进行垃圾回收。但是受很多因素的影响，它经常会抛出OutOfMemoryError异常。在JDK 1.8之后，原来永久代的数据被分到元空间和堆中。`元空间位于本地内存`，存储`类的原信息`，`静态变量和常量池等放入堆中`。

### 运行时常量池

运行时常量池是方法区的一部分。

Class文件中的常量池（编译器生成的`字面量和符号引用`）会在类加载后被放入这个区域。【扩展：[符号引用和直接引用](https://blog.csdn.net/u014656992/article/details/51107127)】

除了编译器生成的常量，还允许动态生成，例如String类的intern().

### 直接内存

在JDK 1.4中新引入了NIO类，它可以使用`Native函数库`直接分配堆外内存，然后通过Java`堆里的DirectByteBuffer对象`作为这块内存的引用进行操作。这样能在一定场景显著提高性能。

## 二、垃圾收集

垃圾收集主要针对`堆和方法区`进行。`程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的`，只存在于线程的生命周期内，`线程结束之后就会消失`，因此不需要对这三个区域进行垃圾回收。

### 判断一个对象是否可被回收

#### 1. 引用计数算法

为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数器为0时的对象可以被回收。

在两个对象出现`循环引用`时，此时引用计数器永远不为0，导致无法对它们进行回收。正是因为循环引用的存在，因为Java不使用引用计数算法。

```java
public class Test{
    public Object instance = null;

    public static void main(String[] args){
        //堆中分配Test()对象空间，栈帧中局部变量a,b
        Test a = new Test();
        Test b = new Test();
        a.instace = b;
        b.instace = a;
        a = null;
        b = null;
        doSomething();
    }
}
```

