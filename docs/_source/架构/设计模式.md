|                   -                   | private | default | protected | public |
| :-----------------------------------: | :-----: | :-----: | :-------: | :----: |
|          本类能不能访问访问           |    √    |    √    |     √     |   √    |
| 同一个包(Package)下的其他类能不能访问 |    ×    |    √    |     √     |   √    |
|     不同包(Package),但是作为子类      |    ×    |    ×    |     √     |   √    |
|           不同包，不是子类            |    ×    |    ×    |     ×     |   √    |



设计模式的用途和优点，再看一些关键的OO设计原则



### 策略模式



拓展一些对象的时候，这些对象`没有全用到父类的所有方法`。

将那些`经常变化的代码提取出来`。

然后将这些经常变化的代码，委托给一个接口实现



使用接口的话，重复代码又会有很多，代码无法复用

接口有行为类！



具体的子类，在创建的时候，确定好方法是什么。



设计原则：

提高可维护性和可拓展性。

1. 找出应用中`需要变化之处`，把他们`独立出来`，不要和那些不需要变化的代码混在一起.【`将变化的代码从父类中提取出来`】
2. 针对`接口编程`，而不是针对实现编程。 【接口有行为类，使用多态，针对接口编程】
3. 多用组合，少用继承



```java
// 抽象类
// 有已经实现的方法 + 抽象未实现的方法 + 经常变化的代码用接口来处理 + 利用多态更改接口的值
public abstract class Duck{
    //抽取出经常变化的代码，用接口去实现它。面向接口编程
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;
    
    //因为这个类是抽象类。不同的子类有不同的实现
	public abstract void display();
    
    //经常变化的代码。委托给对象类实现
    public void performFly(){
        flyBehavior.fly();
    }
    public void performQuack(){
        quackBehavior.quack();
    }
    
    //不经常变化的代码
    public void swim(){
        System.out.println("All ducks float, even decoys!");
    }
    
    //因为采用的是多态，所以我们可以动态的修改行为！
    //策略模式能切换的关键
    public void setFlyBehavior(FlyBehavior fb){
        flyBehavior = fb;
    }
    public void setQuackBehavior(QuackBehavior qb){
        quackBehavior = qb;
    }
}
```

```java
//行为接口，所有的飞行类行为类必须实现接口
public interface FlyBehavior{
    public void fly();
}

//飞行行为的实现，给真的会飞的鸭子使用
public class FlyWithWings implements FlyBehavior{
    public void fly{
        System.out.println("I'm flying!");
    }
}
//飞行行为的实现，给不会飞的鸭子使用
public class FlyNoWay implements FlyBehavior{
    public void fly(){
        System.out.println("I can't fly");
    }
}
//我想用火箭去飞
public class FlyRocketPowerd implements FlyBehavior{
    public void fly(){
        System.out.println("I'm flying with a rocket!");
    }
}
```

```java
//行为接口,所有的叫声必须实现这个接口
public interface QuackBehavior{
    public void quack();
}
//呱呱叫
public class Quack implements QuackBehavior{
    public void quack(){
        System.out.println("Quack");
    }
}
//不会叫
public class MuteQuack implements QuackBehavior{
    public void quack(){
        System.out.println("<Silence>");
    }
}
//吱吱叫
public class Squeak implements QuackBehavior{
    public void quack(){
        System.out.println("Squeak");
    }
}
```

```java
//具体的鸭子
public class MallardDuck extends Duck{
    public MallardDuck(){
        //在构造方法中创建具体的对象。
        //但是，我们说面向接口编程，这里仍然是有可以优化的地方
        quackBehavior = new Quack();
        flyBehavoir = new FlyWithWings();
    }
    
    //抽象方法，必须重写。其他的方法，可以直接使用父类的
    public void display(){
        System.out.println("I'm a real Mallard duck");
    }
}
```

```java
// main方法
public class MiniDuckSimulator{
    public static void main(String[] args){
        Duck mallard = new MallardDuck();
        mallard.performQuack();
        
        //改变行为
        Duck changeDuck = new MallardDuck();
        changeDuck.performFly();
        changeDuck.setFlyBehavior(new FlyRocketPowered());
        changeDuck.performFly();
    }
}
```



### 观察者模式



此系统中有三个部分是`气象站`（获取实际气象数据的物理装置）、`weatherData对象`（当气象站数据`一改变`的时候，根据气象站的数据，更新布告板）和`布告板`（显示目前天气给用户看）



当气象站数据变化的时候，weatherData就会自动执行measurementsChanged()方法。

如果说把更新气象站的数据写到measurementsChanged()方法中，那如果说要随时随地删除增加布告板，那么就不方便。

因为气象站和weatherData耦合在了一起。



观察者模式类似于订阅号、微信公众号、微博、报纸和杂志的订阅、猎头和他的程序员名单



主题对象管理某些数据

当主题内的数据变化，就会通知观察者

观察者已经订阅主题以便在主题数据改变时能够收到更新。



观察者模式定义了对象之间的`一对多`依赖，这样一来，`当一个对象改变状态时`，它的`所有依赖者都会收到通知并自动更新`。



实现观察者模式的方法不止一种，但是以包含`Subject与Observer接口`的类设计的做法是最常见的。



并不一定以现实中的情形去做，现实中的情形是为了帮助我们建模，理解。

当数据改变时，主题通知观察者去做改变。其实是主题遍历自己的数据，然后调用观察者的方法。

当要成为观察者的时候，并不用告诉主题怎么做，仅仅是在观察者的内部调用主题的add方法。

这么做，是为了将观察者和主题解耦。不是主题变化，就直接代码告诉所有的观察者，这样子不利于添加删除观察者。

```java
//主题接口，提供通用方法
public interface Subject{
    //注册观察者、移除观察者、通知观察者
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();
}

//观察者接口，提供通用方法
public interface Observer{
    //当主题的数据改变时（温度、湿度、压力），观察者做的改变
    public void update(float temp, float humidity, float pressure);
}

//布告板需要显示时，需要调用此方法
public interface DisplayElement{
    public void display();
}

public class WeatherData implements Subject{
    private ArrayList observers;
    //温度
    private float temperature;
    //湿度
    private float humidity;
    //压力
    private float pressure;
    
    //构造函数
    public WeatherData(){
        observers = new ArrayList();
    }
    
    public void registerObserver(Observer o){
        observers.add(o);
    }
    public void removeObserver(Observer o){
        int i = observers.index(o);
        if (i >= 0){
            observers.remove(i);
        }
    }
    public void notifyObservers(){
        for (int i = 0; i < observers.size(); i++){
            observer observer = (Observer) observers.get(i);
            observer.update(temperature, humidity, pressure);
        }
    }
    public void measurementChanged(){
        notifyObservers();
    }
    public void setMeasurements(float temperature, float humidity, flaot pressure){
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}

public class CurrentConditionsDisplay implements Observer, DisplayElement{
    private float temperature;
    private float humidity;
    private float weatherData;
    
    public CurrentConditionsDisplay(Subject weatherData){
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }
    
    public void update(float tempertature, float humidity, float pressure){
        this.tmeperature = temperature;
        this.humidity = humidity;
        display();
    }
    
    public void display(){
        System.out.println("Current conditions:" + ·····)
    }
}


public class WeathersStation{
    public static void main(String[] args){
        WeatherData weatherData = new WeatherData();
        
        CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);
        weatherData.setMeasurements(80, 65, 30.4f);
    }
}
```



解耦：

主题把数据发给观察者。  --> 将数据发给自己的ArrayList【把数据存成自己使用了】

观察者主题  ---> 自己有观察者的数据，调用观察者的add()方法



Java API有内置的观察者模式：Observer接口和Observable接口【观察者接口和“可观察者接口”】

![image-20200526202708310](_img/image-20200526202708310.png)

![image-20200526202800915](_img/image-20200526202800915.png)

如何把对象变成观察者？

实现观察者接口java.util.Observer，然后就能调用任何Observable对象的addObserver()方法。不想再当观察者时，调用deleteObserver()方法就可以



```java
import java.util.Observable;
import java.util.Observer;

//继承“可观察者对象”
//“可观察者对象”就是我们上面用到的主题
public class WeatherData extends Observable {
    
    //我们不需要再使用ArrayList添加观察者了，也不需要管理注册和删除观察者了（Observable已经帮我们做好了），所以我们把管理注册和删除观察者的代码给删了

    private float temperature;
    private float humidity;
    private float pressure;

    //我们的构造器不再需要使用ArrayList了
    public WeatherData(){}

    //通知观察者们
    public void measurementsChanged(){
        //★必须在调用notifyObservers()前调用setChanged()，可以看一下上面截图出来的代码，if(!change) return;
        setChanged();
        //这里采取的方式是“拉”
        notifyObservers();
    }

    //自己模拟数据改变
    public void setMeasurements(float temperature, float humidity, float pressure){
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }

    //因为采取的“拉”，所以“拉取”的数据就是通过get方法
    public float getTemperature() {
        return temperature;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }
}
```

```java
//继承观察者接口
class CurrentConditionsDisplay implements Observer{

    //“可观察者对象”，即主题对象
    Observable observable;
    private float temperature;
    private float humidity;

    //向观察者添加自己
    public CurrentConditionsDisplay(Observable observable){
        this.observable = observable;
        observable.addObserver(this);
    }

    //所谓的拉，只是自己主动调用get方法
    //推，就会“可观察者对象”将推的内容放在arg中
    @Override
    public void update(Observable o, Object arg) {
        if (o instanceof WeatherData){
            WeatherData weatherData = (WeatherData)o;
            this.temperature = weatherData.getTemperature();
            this.humidity = weatherData.getHumidity();
            display();
        }
    }

    private void display() {
        System.out.println(temperature + ":" + humidity);
    }
}

```



这里，仍然要注意一下，Observable是一个"类"而不是一个“接口”。这样子就限制了Observable的使用和复用，比如说，如果一个类想要同时继承Observable类和另一个超类的行为，就会陷入两难。



如果你不想使用Observable，你可以自己实现一个Observable接口。



观察者模式在很多地方用到了，比如JavaBeans和Swing中。



要点：

1. 观察者模式定义了对象之间一对多的关系
2. 主题（也就是可观察者）用一个公共的接口来更新观察者(update())
3. 观察者和可观察者之间用松耦合方式结合（loosecoupling），可观察者不知道观察者的细节，只知道观察者实现了观察者接口



### 装饰模式



给爱用继承的人一个全新的设计眼界。



`以对象组合的方式，做到在运行时装饰类。`

`一旦熟悉了装饰技巧，能够在不修改底层代码的情况下，给对象赋予新的职责`



继承威力强大，但是它并不能总是能够实现最好的设计。

不通过继承，如何达到复用呢？利用组合和委托。

`继承在设计子类的时候，是在编译时静态决定的`。而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法拓展对象的行为，就可以在运行时`动态的进行拓展`。

可以利用这个技巧把多个职责，甚至是设计超类时还没想到的职责加在对象上。而且，可以不用修改原来的代码。通过组合对象，可以写新的代码添加新的功能，而无需修改现有的代码。

代码应该如同晚霞的莲花一样的关闭（`免于改变`），如同晨曦的莲花一样地开放（`能够拓展`）



我们的目标是允许`类容易拓展`，在`不修改现有代码的情况下`，就可以搭配新的行为。



我如何让设计的每个部分都遵循开放-关闭原则？

我们实在没有闲工夫把设计的每个部分都这么设计（而且，就算做得到，这也是一种浪费）。遵循开放-关闭原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最优可能改变的地方，然后运用开放=关闭原则。



> 把装饰者对象当成一个”包装者“

1. 装饰者和被装饰者对象有相同的超类型
2. 你可以用一个或多个装饰者包装一个对象            
3. 装饰者可以在所委托被装饰者的行为之前/或之后，加上自己的行为，以达到特殊的目的

装饰者模式：动态地将责任附加到对象之上。若要拓展功能，装饰者提供了比继承更有弹性的替代方案。



装饰者也是继承于超类。虽然用到了继承，但是这么做的重点在于，装饰者和被装饰者必须是一样的类型，也就是有共同的超类，这是相当关键的地方。在这里，我们利用继承达到了”类型匹配“，而不是用继承获得”行为“。

当我们将装饰者与组件组合时，就是在加入新的行为。所得到的新行为，并不是继承自超类，而是由组合对象得来的。

继承Beverage抽象类，是为了有正确的类型，而不是继承他的行为。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。

如果依赖继承，那么类的行为只能在编译时静态决定。

装饰者模式通常采用抽象类，但是在Java中可以使用接口。



```java
public abstract class Beverage {
    String description = "Unknown Beverage";

    public String getDescription() {
        return description;
    }

    public abstract double cost();
}

//浓缩咖啡
class Espresso extends Beverage {
    // 这是是使用父类的description，而不是子类自己定义一个description。
    //这是因为多态是针对“方法”的多态，属性并没有多态
    public Espresso() {
        description = "Espresso";
    }

    @Override
    public double cost() {
        return 1.99;
    }
}

// 综合咖啡
class HouseBlead extends Beverage {
    public HouseBlead() {
        description = "House Blead Coffee";
    }

    @Override
    public double cost() {
        return .89;
    }
}

```



```java
// 调料装饰
// 继承Beverage必须重写cost()
// 继承CondimentDecorator还必须重写getDescription()
abstract class CondimentDecorator extends Beverage {
    @Override
    public abstract String getDescription();
}

// 摩卡调料，装饰类的具体实现
class Mocha extends CondimentDecorator {

    Beverage beverage;

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    //委托
    @Override
    public double cost() {
        return .20 + beverage.cost();
    }

    //委托
    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Mocha";
    }
}

//豆浆调料，装饰类的具体实现
class Soy extends CondimentDecorator {
    Beverage beverage;

    public Soy(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return .15 + beverage.cost();
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Soy";
    }
}

// 奶泡调料，装饰类的具体实现
class Whip extends CondimentDecorator {
    Beverage beverage;

    public Whip(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return .10 + beverage.cost();
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", whip";
    }
}

```

```java
class StarbuzzCoffee {
    public static void main(String[] args) {
        Beverage beverage = new Espresso();
        System.out.println(beverage.getDescription() + " $" + beverage.cost());

        Beverage beverage2 = new HouseBlead();
        beverage2 = new Soy(beverage2);
        beverage2 = new Mocha(beverage2);
        beverage2 = new Mocha(beverage2);
        beverage2 = new Whip(beverage2);
        System.out.println(beverage2.getDescription() + " $" + beverage2.cost());
    }
}


/*
Espresso $1.99
//委托也是一种递归
House Blead Coffee, Soy, Mocha, Mocha, whip $1.54
*/
```



### 工厂模式



通过不同的条件，使用new 创建不同的对象

虽然我是针对接口编程，但是并没有 对修改关闭。如果说，我频繁的要增加删除实例类，那么就要修改原来的代码。

所以这样子其实是不好的。



我们从设计原则找线索：找出变化的部分，把他们从不变的部分分离出来



把创建对象的细节交给工厂。【我就可以在很多个地方使用这个工厂，去创建我想要的东西】

静态工厂，利用静态方法创建一个工厂。



简单工厂模式：

```java
// 创建pizza的工厂，它只做了一件事，帮它的客户创建pizza
public class SimplePizzaFactory{
    public Pizza createPizza(String type){
        Pizza pizza = null;
        
        if (type.equals("cheese")) {
            pizza = new CheesePizza();
        } else if (type.equals("pepperoni")) {
            pizza = new PepperoniPizza();
        } else if (type.equals("clam")) {
            pizza = new ClamPizza();
        } else if (type.equals("veggie")) {
            pizza = new VeggiePizza();
        }
        return pizza;
    }
}

// 披萨店
public class PizzaStore() {
    SimplePizzaFactory factory;
    
    // 创建PizzaStore的时候，需要知道 由哪个Pizza工厂创建Pizza
    public PizzaStore(SimplePizzaFactory factory) {
        this.factory = factory
    }
    
    public Pizza orderPizza(String type) {
        Pizza pizza;
        // 由工厂创建Pizza
        // 我们把 new 操作符替换成 工厂对象 的创建方法。这里不再使用具体实例化。
        pizza = factory.createPizza(type);
        
        pizza.prepare();
        pizza.back();
        pizza.cut();
        pizza.box();
        return pizza;
    }
}

public static void main(String[] args){
	// 先创建一个工厂
    SimplePizzaFactory factory = new SimplePizzaFactory();
    // 创建Pizza店, 将工厂作为参数传给Pizza店
    PizzaStore store = new PizzaStore(facotory);
    // Pizza店创建 Pizza
    store.orederPizza("cheese");
}
```

![image-20200711120543502](_img/image-20200711120543502.png)



---



如果说，Pizza店想要开加盟店，不同地区的加盟店有自己特色的Pizza。

这个时候的工厂模式可以这么用：`原本是由一个对象（工厂对象）负责所有具体类的实例化，现在通过对PizzaStore做一些小转变，变成由一群子类来负责实例化。`

`工厂模式用来处理对象的创建，并将这样的行为封装在子类中，`。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。

```java
// 工厂
public abstract class PizzaStore(){
    public Pizza orderPizza(String type) {
        Pizza pizza;
        
        // 现在createPizza()从工厂对象中移回PizzaStore。
        // createPizza（type） 是本类的一个方法
        pizza = createPizza(type);
        
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        
        return pizza;
    }
    
    // 工厂方法
    // abstract：工厂方法是抽象的，所以依赖子类来处理对象的创建
    // Pizza(Product)：工厂方法必须返回一个产品。超类中定义的方法，通常使用到工厂方法的返回值
    // createMethod(factoryMethod)：工厂方法将客户（也就是超类中的代码，例如orderPizza()）和 实际创建具体产品的代码 分隔开来。
    protected abstract Pizza createPizza(String type);
}
```

```java
// 纽约风味的Pizza 工厂
public class NYPPizzaStore extends PizzaStore {
    @Override
    protected Pizza createPizza(String item) {
        if (item.equals("chess")) {
            return new NYStyleCheesePizza();
        } else if (item.equals("veggie")) {
            return new NYStyleVeggiePizza();
        } else return null;
    }
}
```

```java
// 别忘了，还有Pizza本身
public abstract class Pizza {
    String name;
    String dough;
    String sauce;
    ArrayList topping = new ArrayList();
    
    void prepare(){
        System.out.println("Prepareing" + name + "\nTossin dough.." + "\nAdding sauce.." + "\nAdding toppings:");
        for (int i = 0;i < toppings.size(); i++) {
            System.out.println(toppings.get(i));
        }
    }
    void bake() {
        
    }
    void cut(){
        
    }
    void box(){
        
    }
    public String getName(){
        
    }
}

// 纽约风味的披萨
public class NYStyleCheesePizza extends Pizza {
    public NYStyleCheesePizza(){
        name = "NY Style Sauce and Cheese Pizza";
        dough = "Thin Crust Dough";
        sause = "Marinara Sauce";
        
        toppings.add("Grated Reggiano Cheese");
    }
}
```



```java
public static void main(String[] args) {
    PizzaStore nyPizzaStore = new NYPizzaStore();
    Pizza pizza = nyStore.orderPizza("cheese");
    System.out.println("Ethan ordered a " + pizza.getName() + "\n");
}
```



工厂方法模式：定义了`一个创建对象的接口`，但由`子类决定要实例化的类是哪一个`。工厂方法让类把实例化推迟到子类。

工厂方法模式能够`封装具体类型的实例化`。



如下图：

抽象的Creator提供了一个创建对象的方法的接口，也称为”`工厂方法`“。 在抽象的Creator中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品。但是只有子类真正实现这个工厂方法并创建产品。

工厂模式能够帮助我们将产品的 ”实现“ 从 ”使用“ 中解耦。如果增加产品或者改变产品的实现，Creater 并不会受到影响。（因为Creater与任何ConcreteProduct 之间都不是紧耦合的）

![image-20200704221141757](_img/image-20200704221141757.png)

![image-20200704221100476](_img/image-20200704221100476.png)



简单工厂和工厂方法之间的差异？它们看起来很像，差别在于，在工厂方法中，返回比萨的类是子类？

子类的确看起来很像简单工厂。`简单工厂把全部的事情，在一个地方处理完了，然而工厂方法却是创建一个框架，让子类决定要如何实现`。

简单工厂的做法，可以将对象的创建封装起来，但是简单工厂`不具备工厂方法的弹性，因为简单工厂不能变更正在创建的产品`。



#### 依赖倒置原则

代码里减少对于具体类的依赖是件好事，这个原则有一个响亮而正式的名称：”依赖倒置原则“。



设计原则：`要依赖抽象，不要依赖具体类`。这个原则说明了，不能让高层组件依赖低层组件，而且，不管高层还是低层组件，”两者“都应该依赖于抽象。

所谓的”高层“组件，是由其他低层组件定义行为的类。例如，PizzaStore是一个高层组件，因为它的行为是由比萨定义的：PizzaStore创建不同的比萨对象，准备，烘烤，切片，装盒；而披萨本身属于低层组件。



PizzaStore是”高层组件“，而披萨实现的是”底层组件“。我们的代码PizzaStore应该依赖于抽象类（Pizza类），而不能是具体的实例类（NYPizzaStore类）。

![image-20200704232431997](_img/image-20200704232431997.png)



几个指导方针帮助你遵循依赖倒置原则：

1. 变量不可持有具体类的引用。如果使用new，就会持有具体具体类的引用。你可以改用工厂来避开这样的做法。
2. 不要让类派生具体类（应该让具体类继承于抽象类/接口）。如果派生`自`具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类）
3. 不要覆盖基类（父类）中已实现的方法。如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享。



但是如果完全遵循这样子的原则，一个简单的程序都要写的很复杂！。所以`我们应该尽量达到这个原则，而不是随时随地要遵循这个原则`。



---



这个时候，为了确保每家加盟店使用的原料都是统一的。你打算建造一家生产原料的工厂，并将原料运送到各加盟店。



开始为工厂定义一个接口，这个接口负责创建所有的原料

```java
// 原料工厂
public interface PizzaIngredientFactory(){
    // 生面团
    public Dough createDough();
    // 酱汁
    public Sauce createSauce();
    // 奶酪
    public Cheese createCheese();
    // 蔬菜
    public Veggies[] createVeggies();
    // 意大利香肠
    public Pepperoni createPepperoni();
    // 蛤
    public Clams createClam();
}
```

接下来要为每个区域创建一个工厂。

来自纽约的原料工厂

```java
// 具体原料工厂必须实现PizzaIngredientFactory这个接口，纽约工厂也不例外
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
    public Dough createDough() {
        // 薄皮面团
        return new ThinCrustDough();
    }
    
    public Sauce createSauce() {
        // 意大利酱
        return new MarinaraSauce();
    }
    
    public Cheese createCheese() {
        // 雷吉亚诺奶酪
        return new ReggianoCheese();
    }
    
    public Veggies[] createVeggies() {
        // 大蒜， 洋葱， 蘑菇， 红辣椒
        Veggies veggies[] = {new Garlic(), new Onion(), new Mushroom(), new ReadPepper()};
        return veggies;
    }
    
    public Pepperoni createPepperoni() {
        // 切片的意大利香肠
        return new SlicedPepperoni();
    }
    
    public Clams createClam() {
        // 鲜蛤
        return new FreshClams();
    }
}
```

重做披萨，好让它们只使用工厂生产出来的原料。我们从抽象的Pizza开始

```java
public abstract class Pizza() {
    // 每个Pizza都会持有一组在准备时会用到的原料
    String name;
    Dough dough;
    Sauce sauce;
    Veggies veggies[];
    Cheese cheese;
    Pepperoni pepperoni;
    Clams clam;
    
    // 现在把prepare() 方法声明成抽象。在这个方法中，我们需要收集披萨所需的原料，而这些原料当然来自原料工厂
    abstract void prepare();
    
    void bake() {
        System.out.println("Bake for 25 minutes at 350");
    }
    
    void cut() {
        System.out.println("Cutting the pizza into diagonal slices");
    }
    
    void box() {
        System.out.println("Place pizza in oficial PizzaStore box");
    }
    
    void setName(String name) {
        this.name = name;
    }
    
    String getName() {
        return name;
    }
}
```



```java
public class CheesePizza extends Pizza {
    // 要制作比萨，需要工厂提供原料。所以每个披萨类都需要从构造器参数中得到一个工厂，并把这个工厂存储到一个实例变量中
    PizzaIngredientFactory ingredientFactory();
    
    public CheesePizza(PizzaIngredientFatory ingredientFactory) {
        this.ingredientFatory = ingredientFactory;
    }
    
    void prepare() {
        System.out.println("Preparing" + name);
        // 需要的原料，都是跟工厂要
        dough = ingredientFactory.createDough();
        sauce = ingredientFactory.createSause();
        cheese = ingredientFactory.createCheese();
    }
}
```



Pizza的代码利用相关的工厂生产原料。`所生产的原料依赖所使用的工厂`，Pizza类根本不关心这些原料，它只知道如何制作披萨。现在，Pizza和区域原料之间被解耦，无论原料工厂是在落基山脉还是在西北地区，Pizza类都可以轻易地复用，完全没有问题。



回到Pizza店

```java
public class NYPizzaStore extends PizzaStore {
    protected Pizza createPizza(String item) {
        Pizza pizza = null;
        PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();
    }
    
    if (item.equals("cheese")) {
        pizza = new CheesePizza(ingredientFactory);
        pizza.setName("New York Style Cheese Pizza");
    } else if (item.equals("veggie")) {
        pizza = new VeggiePizza(ingredientFactory);
        pizza.setName("New York Style Veggie Pizza");
    } else if (item.equals("clam")) {
        pizza = new ClamPizza(ingredientFactory);
        pizza.setName("New York Style Clam Pizza");
    } else if (item.equals("pepperoni")) {
        pizza = new PepperoniPizza(ingredientFactory);
        pizza.setName("New York Style Pepperoni Pizza");
    }
    return pizza;
}
```

![image-20200711121721396](_img/image-20200711121721396.png)



一连串地的代码改变，我们做了什么？

我们引入了新类型的工厂，也就是所谓的抽象工厂，来创建披萨原料家族。

通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口数写代码，我们的代码从实际工厂中解耦，以便在不同的上下文实现各式各样的工厂。



抽象工厂：这个模式可以创建产品的家族。

抽象工厂模式，提供一个接口，用于创建相关或依赖对象的家族，而不需熬明确指定具体类。



抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。



---



全部组合起来

![image-20200711125602370](_img/image-20200711125602370.png)

![image-20200711125812432](_img/image-20200711125812432.png)

我们可以看到，继承自PizzaStore的NYPizzaStore 和 ChicagoPizzaStore 是大心脏。

根据地域不同，继承自 PizzaStore， 采用了工厂方法模式。

要创建不同的披萨，采用了工厂方法模式（类似于简单工厂方法模式）

要创建具体的披萨，必须使用抽象工厂方法模式，所以NYPizzaStore 和 ChicagoPizzaStore 中也含有 PizzaIngredientFactore属性。



我们再来回顾一下大心脏 NYPizaStore 的写法

```java
public class NYPizzaStore extends PizzaStore {

	// 工厂方法模式
	@Override
	protected Pizza createPizza(String item) {
		Pizza pizza = null;
		PizzaIngredientFactory ingredientFactory = 
			new NYPizzaIngredientFactory();
 
		if (item.equals("cheese")) {
  
			// 将工厂参数传进去，利用 抽象工厂模式 创建披萨
			pizza = new CheesePizza(ingredientFactory);
			pizza.setName("New York Style Cheese Pizza");
  
		} else if (item.equals("veggie")) {
 
			pizza = new VeggiePizza(ingredientFactory);
			pizza.setName("New York Style Veggie Pizza");
 
		} else if (item.equals("clam")) {
 
			pizza = new ClamPizza(ingredientFactory);
			pizza.setName("New York Style Clam Pizza");
 
		} else if (item.equals("pepperoni")) {

			pizza = new PepperoniPizza(ingredientFactory);
			pizza.setName("New York Style Pepperoni Pizza");
 
		} 
		return pizza;
	}
}
```



---

工厂方法：可以把客户的代码从需要实例化的具体类中解耦。或者如何你目前还不知道将来需要实例化哪些具体类时，也可以用工厂方法。使用方式很简单，只要继承父类，并实现父类的工厂方法就可以

抽象工厂：当需要创建产品家族和想让制造的相关产品集合起来时，可以使用抽象工厂。



### 自己的思考



如何解耦呢？OO原则

1. `封装变化`：将`经常改变的代码`提取出来，将这些方法放在`接口`里。为了防止`因为接口而导致的代码冗余`，用`类实现接口的方法`，此后，就可以`面向接口编程`，去调用类的方法。
2. 针对接口编程，不针对实现编程：实际意思是，针对`父类编程`，利用`反射`，可以很灵活，大大解耦。
3. 多用组合，少用继承。比如鸭子的行为不是继承来的，而是`和其他行为对象“组合”来的`
4. 为交互对象之间的松耦合设计而努力。怎么将两个对象进行解耦呢？比如在观察者模式中，“可观察者”对象里有“观察者”的列表，“可观察者”只需要调用update()就可以了，不用管有多少个观察者，观察者具体是什么。“观察者”里面有“可观察者”，“观察者”只需要调用“可观察者“的add方法就可以了，也不管”可观察者“是谁，怎么实现
5. 类应该能够扩展开放，对修改关闭







`策略模式`就是说，`在类中有接口对象`，然后调用`接口对象的方法`。利用`反射`，可以调用`不同的方法`，或者`改变接口的实例`（换一个对象），从而实现调用的方法改变。



观察者模式就是说，可观察者对象`先定义自己的方法`（增加、删除、通知观察者），观察者对象先定义自己的方法（收到通知时要怎么做）。【当然，上面的方法也是经常变化的，将这些变化的代码提取出来，放在接口里面】。

然后“可观察者对象”中有多个“观察者对象的实例”（ArrayList / Vector），当“可观察者想要“通知”观察者”的时候，就for循环，调用观察者的update()

“观察者”有“可观察者”对象，当自己想要注册的时候，就调用“可观察者”的add，想要删除的时候，就调用remove。

