### 运输层协议概述

从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务（端口），它属于面向通信部分的最高层，同时也是用户功能的最底层。

当`网络的边缘部分中的两台主机`使用网络的核心部分的功能进行`端到端的通信`时，只有主机的`协议栈才有运输层`，而网络核心部分中的`路由器`在`转发分组`时，都只用到下三层的功能【因为在分组转发中，不用直接交付，也用不到端口】。

从IP层的角度来说，通信的两端是两台主机。IP数据报的首部明确地标志了两台主机的IP地址。但“两台主机之间的通信”不是很明确。这是因为，`真正进行通信的实体是进程，是这台主机的一个进程和另一台主机的另一个进程在交换数据。`

因此，运输层有一个很重要的功能--复用（multiplexing）和分用（demultiplexing）。

- 复用：是发送方不同的应用进程都可以使用同一个运输层协议传送数据（还要加上适当的首部）
- 分用：是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程

`运输层提供应用进程间的逻辑通信，而这，需要应用端口。`

#### 运输层的两个主要的协议

运输层有两个主要的协议：用户数据报协议UDP（User Datagram Protocol）、传输控制协议TCP（Transmission Control Protocol）

- TCP是面向连接的，是逻辑上的一条全双工的可靠信道（尽管下面的网络层是不可靠的），但是TCP不提供广播和多播服务，且为了可靠连接需要占用许多处理机资源；单位是TCP报文段
- UDP是无连接的，逻辑上仍是不可靠信道，但是UDP在某些方面下是最有效的工作方式；单位是UDP用户数据报

![TCPUDP.jpg](../../_img/TCPUDP.jpg)

#### 运输层的端口

软件端口是应用层各种进程与运输实体层间交互的一种`地址`。在TCP、UDP中有源端口和目的端口这两个重要的字段

- 服务器端使用的端口

这里有两类，一类是熟知端口号（well-known port number）或系统端口号，数值为0~1023。

![熟知端口号.jpg](../../_img/熟知端口号.jpg)

另一类是登记端口号。数值为1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防重复。

|  应用  | 端口号 | 运输层协议 |
| :----: | :----: | :--------: |
| Mysql  |  3306  |    TCP     |
| Oracle |  1521  |    TCP     |
| Tomcat |  8080  |            |

- 客户端使用的端口号

数字为49152~65535。这类端口号仅在客户进程运行时才动态选择，因此又叫短暂端口号。

#### 用户数据报协议UDP

用户数据报协议UDP只在IP数据报的基础上增加了很少的功能，这就是分用和复用【端口】的功能以及差错检错的功能。

UDP的主要特点是：

1. UDP是无连接的
2. UDP使用尽最大努力交付，即不保证可靠交付
3. UDP是面向报文的。发送方的UDP对应用程序交下来的报文，既不合并、也不拆分，而是保留这些报文的边界，直接添加首部后就向下交付IP层。也就是说，UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，在IP层则需要分片；若报文太短，则IP数据报的首部相对较长，效率不高
4. UDP没有拥塞控制。因此网络出现拥塞不会使源主机的发送速率降低。对IP电话、实时视频会议等还是很重要的；但是没有拥塞控制，可能会导致网络产生严重的拥塞问题。
5. UDP支持一对一、一对多、多对一的交互通信方式
6. UDP首部开销小

##### UDP的首部格式

![UDP数据报.jpg](../../_img/UDP数据报.jpg)

![UDP检验和.jpg](../../_img/UDP检验和.jpg)

如果接收方UDP发现报文中的目的端口号不正确（即不存在对应该端口号的应用进程），就丢弃该报文，并丢弃该报文，并由`网际控制报文ICMP发送“端口不可达”差错报文`给发送方。(tracert，就是发送的UDP用户数据报报告一个非法的UDP端口，结果ICMP就发送“端口不可达”差错报文，因而达到测试的目的)

#### 传输控制协议TCP

TCP的主要特点：

1. TCP是`面向连接的运输层协议`：跟打电话一样，使用TCP协议之间，必须先建立连接，在传输数据完毕后，必须释放已经建立的连接。
2. 每一条TCP只能`点对点`
3. TCP`提供可靠交付`的服务
4. TCP提供`全双工通信`：TCP允许通信双方的应用进程`在任何时候都能发送数据`。TCP连接在两端都设有`发送缓存`和`接收缓存`，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收的时候，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓冲中的数据.
5. 面向字节流：TCP中的流是指`流入到进程或从进程流出的字节序列`

![TCP面向字节流.jpg](../../_img/TCP面向字节流.jpg)
![TCP面向字节流.jpg](../../_img/TCP面向字节流2.jpg)

##### TCP报文段首部格式

![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式1.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式2.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式3.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式4.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式5.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式6.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式7.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式8.jpg)
![TCP报文段首部格式.jpg](../../_img/TCP报文段首部格式9.jpg)

##### TCP的连接

TCP把连接作为最基本的抽象。每一条TCP连接有两个端点，TCP连接的端点叫做套接字（socket）或插口。

套接字 socket = （IP地址 ： 端口号）

##### 可靠传输的原理

虽然IP层只提供尽最大努力服务（不可靠的传输），但是在TCP层，我们可以使用可靠传输的协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来不可靠的传输信道就能够实现可靠传输了。

##### 停止等待协议

全双工通信的双方既是发送方，也是接收方。但是为了方便，我们仅考虑A发送数据而B接收数据并发送确认。因此A叫做发送方，B叫做接收方。

“停止等待协议”就是每发送一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。

![停止等待协议1.jpg](../../_img/停止等待协议1.jpg)
![停止等待协议2.jpg](../../_img/停止等待协议2.jpg)
![停止等待协议3.jpg](../../_img/停止等待协议3.jpg)
![停止等待协议4.jpg](../../_img/停止等待协议4.jpg)
![停止等待协议5.jpg](../../_img/停止等待协议5.jpg)
![停止等待协议5.jpg](../../_img/停止等待协议6.jpg)
![停止等待协议5.jpg](../../_img/停止等待协议7.jpg)
![停止等待协议5.jpg](../../_img/停止等待协议8.jpg)

##### 连续ARQ协议

滑动窗口是TCP的精髓，这里先给出连续ARQ的基本概念。

图5-13(a)表示发送方维持发送端口，它的意义是：位于发送端口内的`5个分组都可以连续发送出去`，`而不需要等待对方的确认`。这样，信道利用率就提高了。

接收方一般是采用`累计确认`的方式。也就是说，接收方不必对收到的分组逐个发送确认，而是`在收到几个分组后`，对按序到达的`最后一个分组发送确认`，这就表示：到这个分组为止的所有分组都正确收到了。

但是，累计确认有优点也有缺点。`优点是：容易实现，即使确认丢失后也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。`

![停止等待协议5.jpg](../../_img/停止等待协议9.jpg)

##### 以字节为单位的滑动窗口

TCP的滑动窗口是以字节为单位的。为了方便，我们故意把下面图例中的字节编号取得很小。

现假定A收到了B发来的确认报文段，其中`确认号`是31,而`窗口`是20字节，而(这表明B期望收到的下一个序号是31，而序号30为止的数据已经收到了)。`根据这两个数据，A就构造出自己的发送端口`：

![滑动窗口.jpg](../../_img/滑动窗口.jpg)

---

![滑动窗口.jpg](../../_img/滑动窗口1.jpg)

---

![滑动窗口.jpg](../../_img/滑动窗口2.jpg)

**A的发送窗口：**

1. 在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。
2. 以发送过的数据，在没有收到确认之前，必须暂时保留，以便在超时重传时使用

窗口的后沿和前沿都可以不动或向前移动；但是不能向后移动！后延不能向后移动，因为不能撤销确认过的报文，前延强烈不赞成向后移动，因为很有可能发送方已经发送了很多数据，但是现在又说不能发送后面的一些数据，这样子会产生一些错误。

**A的发送缓存用来存放：**

1. 发送应用程序传送给TCP准备发送的数据
2. TCP已发出但是未收到确认的数据

**B的接收缓存用来存放：**

1. 按序到达的、但尚未被接收应用程序读取的数据
2. 未按序到达的数据

**还要再强调几点：**

1. 虽然A的发送端口是根据B的接收窗口设置的，但是发送方A还可能根据网络当时的拥塞情况适当减少自己的发送端口
2. TCP有累计确认的功能，这样子可以减少传输开销。
3. TCP的通信时全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送端口和接收端口。

##### 超时重传时间的选择

运输层的超时重传时间应该设置为多大呢？

![超时重传1.jpg](../../_img/超时重传1.jpg)
![超时重传2.jpg](../../_img/超时重传2.jpg)
![超时重传3.jpg](../../_img/超时重传3.jpg)
![超时重传4.jpg](../../_img/超时重传4.jpg)

##### TCP的流量控制【接收方控制发送方的发送】

所谓流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。

利用滑动窗口机制可以很方便地在TCP连接上实现对发送方地流量控制。

![流量控制.jpg](../../_img/流量控制.jpg)

1. 图中大写ACK表示首部中确认位ACK，小写ack代表确认字段的值。
2. `rwnd（receiver window）`，由接收方的`接收窗口`的大小控制，并写在`TCP首部的"窗口"，代表接收端能够接收的最大字节数`,发送方的发送窗口不能超过接收方给出的接收窗口的`数值`。
3. TCP的窗口单位是字节，不是报文段。

我们应当注意到，接收方的主机B进行了三次流量控制。第一次把窗口减少到rwnd=300，第二次又减到rwnd=100，最后减到rwnd=0，即不允许再发送数据了。这种发送方暂停发送的状态持续到主机B重新发出一个新的窗口值为止、或持续计时器打破死锁。我们还应当注意到，B向A发送的三个报文段ACK=1，`只有在ACK=1时，确认号字段才有意义`。

有一种情况是，接收方发送零窗口的报文段不久后，B的接收缓存又有了一些存储空间。但是B向A发送的rwnd报文丢失了，A就一直处于等待状态。

为了解决这个问题，TCP接收端设置有`持续计时器（persistence timer）`,只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出现在的窗口值。如果仍是0，那么收到报文段的一方就重新设置持续计时器。

###### TCP的传输效率

应用程序把数据传送到TCP发送缓存后，剩下的任务就由TCP来控制。可以用不同的机制来控制TCP报文段的`发送时间`。

![流量控制2.jpg](../../_img/流量控制2.jpg)
![流量控制2.jpg](../../_img/流量控制3.jpg)

##### TCP的拥塞控制【路由器控制发送方的发送】

在计算机网络中链路容量（即带宽）、交换节点中的缓存和处理及等，都是`网络中的资源`。

出现拥塞的情况为：

![拥塞公式.jpg](../../_img/拥塞公式.jpg)

对于上面的不等式，不是仅仅增大某一个网络中的资源就能解决问题，这往往需要所有的部分都平衡了，问题才会得到解决。

`这里区分一下拥塞控制和流量控制：`

所谓`拥塞控制`就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是`一个全局性的过程`，涉及到所有的主机、所有的`路由器`，以及与降低网络传输性能有关的所有因素。

而`流量控制`往往是指点对点通信量的控制，是个`端到端`的问题（接收端控制发送端）。流量控制说要做的就是抑制发送数据的速率，以便使接收端来得及接收。

我们来看一下网络中拥塞控制能起到的作用：

![拥塞控制的作用.jpg](../../_img/拥塞控制的作用.jpg)

拥塞控制是一个动态的（不是静态的）的问题，是很难控制的。有些时候甚至是拥塞控制本身（发送让输出端减少输出的报文）引起网络性能恶化甚至是发送死锁的原因，这点也应当引起重视。

---

###### 拥塞控制的方法

进行拥塞控制的算法有四种：慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）。

为了集中精力介绍拥塞控制，我们假定：

1. 数据是单方向传送的，对方只传送确认报文
2. 接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。

---

![拥塞控制方法4.jpg](../../_img/拥塞控制方法4.jpg)
![拥塞控制方法5.jpg](../../_img/拥塞控制方法5.jpg)
![拥塞控制方法6.jpg](../../_img/拥塞控制方法6.jpg)
![拥塞控制方法7.jpg](../../_img/拥塞控制方法7.jpg)
![拥塞控制方法8.jpg](../../_img/拥塞控制方法8.jpg)
![拥塞控制方法9.jpg](../../_img/拥塞控制方法9.jpg)
![拥塞控制方法10.jpg](../../_img/拥塞控制方法10.jpg)

在上面讲述拥塞控制，是假设接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。但实际上接收方的缓存空间总是有限的。接收方根据自己的接收能力设置了rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给传送方。

因此，`发送方窗口的上限值 = Min[rwnd , cwnd]`

##### 主动队列管理AQM

网络层的路由器`丢弃分组`对TCP拥塞控制的影响也很大。

在网络中通常有很多的TCP连接（它们有不用的源点和终点），这些连接中的报文段通常是复用在网络层的IP数据报中传送。但路由器的缓存满了之后，发送了路由器的尾部丢弃，就可能会影响到多条TCP连接（这些TCP连接发送的报文段都被这个路由器丢弃掉了），结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP的术语中称为全局同步（global syncronization）。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增加了很多。

为了避免网络中发生全局同步现象，可以使用主动队列管理AQM（Active Queue Management）。所谓主动就是，路由器的队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞的征兆时），就以某一概率p把新到达的分组随机丢弃，这样子，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥塞控制。

##### TCP的运输连接管理

TCP协议是`面向连接`的协议。运输连接是用来`传送TCP报文`的。因此连接有三个阶段：`连接建立`、`数据传送`和`连接释放`。运输连接的管理就是使运输连接的建立和释放都能正常地进行。

在TCP连接建立过程中要解决以下三个问题：

1. 要使每一方能够确知对方的存在
2. 要允许协商一些参数（如窗口最大值、是否使用窗口扩大选项和时间戳选项以及服务质量等）
3. 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配

###### TCP的连接建立【三次握手】

TCP的连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段。如图：

![三次握手.jpg](../../_img/三次握手.jpg)

上面给出的连接建立过程叫做三报文握手。请注意，在上图中，B发送给A的报文段，也可以拆成两个部分报文段。可以先发送一个确认报文段（`ACK=1，ack= x+1`），然后再发送一个同步报文段（SYN=1，seq=y）。这样的过程就变成了四报文握手，但是效果是一样的。

为什么A最后一次还要确认呢？主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。

所谓的“已失效的连接请求报文段”是这样子产生的。假设有这么一种异常情况，A发出的第一个连接请求并没有丢失，而是在某个网络结点长时间滞留了，以致延误到A连接释放后，B才在之后的某个时间段收到A的连接请求报文段。这本来是一个早已失效的报文段，但是B收到此失效的报文段，同意了连接。假定不采用报文握手，那么只要B发出确认，连接就建立了。

但是现在的A并没有发出建立连接的请求，因此不理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来的数据。B的许多资源就这样子白白浪费了。

###### TCP的连接释放【四次挥手】

![TCP释放.jpg](../../_img/TCP释放.jpg)

###### TCP的有限状态机

注意图中有三种不同的箭头。`粗实线箭头`表示对`客户进程`的正常变迁。`粗虚线箭头`表示对`服务器进程`的正常变迁。另一种箭头代表`异常变迁`。

![有限状态机.jpg](../../_img/有限状态机.jpg)

1. 当主机A、B都作为客户端的时候，并且A、B都向彼此发送SYN，则A、B的状态变迁都是：CLOSE -> SYN-SEND -> SYN-RECEIVE -> ESTABLISH
